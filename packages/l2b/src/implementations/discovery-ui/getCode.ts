import {
  type ConfigReader,
  combineImplementationHashes,
  type DiscoveryPaths,
  flatteningHash,
  get$Implementations,
} from '@l2beat/discovery'
import { ChainSpecificAddress } from '@l2beat/shared-pure'
import { existsSync, readdirSync, readFileSync } from 'fs'
import { join } from 'path'
import { isDeepStrictEqual } from 'util'
import {
  getAllProjectDiscoveries,
  getProjectDiscoveries,
} from './getDiscoveries'
import type { ApiCodeResponse } from './types'

export function addFlattenerNote(code: string): string {
  const note = [
    '/*',
    ' * NOTE: This file was generated by Flattener, an internal tool built by L2BEAT.',
    ' * Flattener gathers every Solidity source file that the compiler actually',
    ' * embeds into the deployed bytecode and stitches them into one file.',
    ' *',
    ' * What you are reading is therefore the exact logic that runs on‑chain, but it',
    ' * skips anything the compiler ignored (tests, scripts, unused contracts, etc.).',
    ' * Paths and line numbers will not match block‑explorer views. This snapshot is',
    ' * meant to be used for auditing or diffing, keep in mind that some declarations',
    ' * might be missing from the flattened source code.',
    ' */',
    '',
    '',
  ]
  return note.join('\n') + code
}

interface CodePathResult {
  entryName: string | undefined
  codePaths: { name: string; path: string }[]
}

function isFlatCodeCurrent(
  configReader: ConfigReader,
  project: string,
  address: ChainSpecificAddress,
  codePaths: CodePathResult['codePaths'],
): boolean {
  const chain = ChainSpecificAddress.longChain(address)

  const discovery = configReader.readDiscovery(project, chain)
  const discoveries = [
    discovery,
    ...(discovery.sharedModules ?? []).map((module) =>
      configReader.readDiscovery(module, chain),
    ),
  ]
  const discoHashes =
    discoveries.flatMap((d) => d.entries).find((e) => e.address === address)
      ?.sourceHashes ?? []

  const flatHashes = codePaths.map(({ path }) =>
    flatteningHash(readFileSync(path, 'utf-8')),
  )
  const [proxy, ...implementations] = flatHashes
  const calculatedHashes = [proxy]
  if (implementations.length === 1) {
    calculatedHashes.push(implementations[0])
  } else if (implementations.length > 1) {
    calculatedHashes.push(combineImplementationHashes(implementations))
  }

  return isDeepStrictEqual(discoHashes.sort(), calculatedHashes.sort())
}

export function getCode(
  paths: DiscoveryPaths,
  configReader: ConfigReader,
  project: string,
  address: ChainSpecificAddress,
  checkFlatCode = false,
): ApiCodeResponse {
  const { entryName, codePaths } = getCodePaths(
    paths,
    configReader,
    project,
    address,
  )

  if (checkFlatCode) {
    if (!isFlatCodeCurrent(configReader, project, address, codePaths)) {
      throw new Error('Flat code is outdated')
    }
  }

  return {
    entryName,
    sources: codePaths
      .map(({ name, path }) => ({
        name: name,
        code: addFlattenerNote(readFileSync(path, 'utf-8')),
      }))
      .sort((a, b) => compareFiles(a.name, b.name)),
  }
}

export function getAllCode(
  paths: DiscoveryPaths,
  configReader: ConfigReader,
  project: string,
): Record<string, ApiCodeResponse> {
  const result: Record<string, ApiCodeResponse> = {}
  const discoveries = getAllProjectDiscoveries(configReader, project)

  // Get all unique addresses across all chains
  const allAddresses = discoveries.flatMap((discovery) =>
    discovery.entries
      .filter((e) => e.type === 'Contract')
      .map((entry) => entry.address),
  )

  for (const fullAddress of allAddresses) {
    try {
      const { entryName, codePaths } = getCodePaths(
        paths,
        configReader,
        project,
        fullAddress,
      )

      const availableCodePaths = codePaths.filter(({ path }) =>
        existsSync(path),
      )

      result[fullAddress] = {
        entryName,
        sources: availableCodePaths
          .map(({ name: fileName, path }) => ({
            name: fileName,
            code: addFlattenerNote(readFileSync(path, 'utf-8')),
          }))
          .sort((a, b) => compareFiles(a.name, b.name)),
      }
    } catch (error) {
      console.error(`Failed to get code for address ${fullAddress}`, error)
    }
  }

  return result
}

export function getCodePaths(
  paths: DiscoveryPaths,
  configReader: ConfigReader,
  project: string,
  address: ChainSpecificAddress,
): CodePathResult {
  const chain = ChainSpecificAddress.longChain(address)
  const discoveries = getProjectDiscoveries(configReader, project, chain)

  for (const discovery of discoveries) {
    const entry = discovery.entries.find((x) => x.address === address)
    if (!entry) {
      continue
    }

    const similar = discovery.entries.filter((x) => x.name === entry.name)
    const hasImplementations = get$Implementations(entry.values).length > 0

    const name =
      similar.length > 1 ? `${entry.name}-${entry.address}` : `${entry.name}`
    const root = join(
      configReader.getProjectChainPath(discovery.name, chain),
      '.flat',
    )

    if (!hasImplementations) {
      return {
        entryName: entry.name,
        codePaths: [
          { name: `${entry.name}.sol`, path: join(root, name + '.sol') },
        ],
      }
    }
    const dir = readdirSync(join(root, name))
    const codePaths = dir
      .map((file) => ({
        name: file,
        path: join(root, name, file),
      }))
      .sort((a, b) => compareFiles(a.name, b.name))
    return {
      entryName: entry.name,
      codePaths,
    }
  }

  return { entryName: undefined, codePaths: [] }
}

function compareFiles(a: string, b: string) {
  return fileNameToOrder(a) - fileNameToOrder(b)
}

function fileNameToOrder(name: string) {
  const ending = name.match(/\.(\w+)\.sol/)?.[1]
  if (!ending) {
    return 1
  }
  if (ending === 'p') {
    return 0
  }
  return /^\d+$/.test(ending) ? Number.parseInt(ending) : 2
}
