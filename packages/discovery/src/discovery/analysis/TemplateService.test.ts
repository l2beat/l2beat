import { EthereumAddress, Hash256 } from '@l2beat/shared-pure'
import { expect, mockFn } from 'earl'
import { ContractSources } from '../source/SourceCodeService'
import { Shape, TemplateService, hashFirstSource } from './TemplateService'

const CORRECT_SUPERCHAIN_CONFIG_ADDR = EthereumAddress(
  '0x95703e0982140D16f8ebA6d158FccEde42f04a4C',
)
const FAKE_SUPERCHAIN_CONFIG_ADDR = EthereumAddress(
  '0x26C7bFB430d68Bf74d2d52497836d4336b555dE7',
)
const CORRECT_SUPERCHAIN_CONFIG_IMPLEMENATION_HASH = Hash256(
  '0x3ac96c9c95e25f689f65a50f24b325e3f891029cb1cea96dc642418bbb535b1d',
)

const CORRECT_SUPERCHAIN_SOURCES_HASH = Hash256(
  '0x3ac96c9c95e25f689f65a50f24b325e3f891029cb1cea96dc642418bbb535b1d',
)

describe(TemplateService.prototype.findMatchingTemplatesByHash.name, () => {
  it("doesn't match opstack/SuperchainConfig because address is not in validAddresses", () => {
    const templateService = new TemplateService()
    templateService.getAllShapes = mockFn().returns(templateShapes)
    const result = templateService.findMatchingTemplatesByHash(
      CORRECT_SUPERCHAIN_SOURCES_HASH,
      FAKE_SUPERCHAIN_CONFIG_ADDR,
    )
    expect(result).toEqual(['opstack/SuperchainConfigFake'])
  })

  it('matches ONLY opstack/SuperchainConfig because address is in validAddresses and is more specific', () => {
    const templateService = new TemplateService()
    templateService.getAllShapes = mockFn().returns(templateShapes)
    const result = templateService.findMatchingTemplatesByHash(
      CORRECT_SUPERCHAIN_SOURCES_HASH,
      CORRECT_SUPERCHAIN_CONFIG_ADDR,
    )
    // The opstack/SuperchainConfigFake template is not returned
    // even though there is an implementation match. That's because
    // the more specific match (criteria+hash) is found.
    expect(result).toEqual(['opstack/SuperchainConfig'])
  })
})

describe(hashFirstSource.name, () => {
  it('coorectly hashes the first source', () => {
    const hash = hashFirstSource(superchainConfigSources)
    expect(hash).toEqual(CORRECT_SUPERCHAIN_SOURCES_HASH)
  })
})

const templateShapes: Record<string, Shape> = {
  'opstack/SuperchainConfig': {
    criteria: {
      validAddresses: [CORRECT_SUPERCHAIN_CONFIG_ADDR.toString()],
    },
    hashes: [CORRECT_SUPERCHAIN_CONFIG_IMPLEMENATION_HASH],
  },
  'opstack/SuperchainConfigFake': {
    hashes: [
      Hash256(
        '0x65dcaf0bdde7cc90f916020b1615321a4b086bfd802f2c27f6ed226fc486b65d',
      ),
      CORRECT_SUPERCHAIN_CONFIG_IMPLEMENATION_HASH,
    ],
  },
  'opstack/SystemConfig': {
    hashes: [
      Hash256(
        '0x5c566f7b9bd649708500a4ea89e4031d2dad1273ce56f6cb5e67d0193f136eb1',
      ),
      Hash256(
        '0x8594410431f0c8cc86d641b9954c3ad91e81fecc79f25ec8d62b294c44201533',
      ),
    ],
  },
}

const superchainConfigSources: ContractSources = {
  name: 'SuperchainConfig',
  isVerified: true,
  abi: [
    'constructor(address _admin)',
    'event AdminChanged(address previousAdmin, address newAdmin)',
    'event ConfigUpdate(uint8 indexed updateType, bytes data)',
    'event Initialized(uint8 version)',
    'event Paused(string identifier)',
    'event Unpaused()',
    'event Upgraded(address indexed implementation)',
    'function GUARDIAN_SLOT() view returns (bytes32)',
    'function PAUSED_SLOT() view returns (bytes32)',
    'function admin() returns (address)',
    'function changeAdmin(address _admin)',
    'function guardian() view returns (address guardian_)',
    'function implementation() returns (address)',
    'function initialize(address _guardian, bool _paused)',
    'function pause(string _identifier)',
    'function paused() view returns (bool paused_)',
    'function unpause()',
    'function upgradeTo(address _implementation)',
    'function upgradeToAndCall(address _implementation, bytes _data) payable returns (bytes)',
    'function version() view returns (string)',
  ],
  abis: {
    CORRECT_SUPERCHAIN_CONFIG_ADDR: [
      'constructor(address _admin)',
      'event AdminChanged(address previousAdmin, address newAdmin)',
      'event Upgraded(address indexed implementation)',
      'function admin() returns (address)',
      'function changeAdmin(address _admin)',
      'function implementation() returns (address)',
      'function upgradeTo(address _implementation)',
      'function upgradeToAndCall(address _implementation, bytes _data) payable returns (bytes)',
    ],
    '0x53c165169401764778F780a69701385eb0FF19B7': [
      'constructor()',
      'event ConfigUpdate(uint8 indexed updateType, bytes data)',
      'event Initialized(uint8 version)',
      'event Paused(string identifier)',
      'event Unpaused()',
      'function GUARDIAN_SLOT() view returns (bytes32)',
      'function PAUSED_SLOT() view returns (bytes32)',
      'function guardian() view returns (address guardian_)',
      'function initialize(address _guardian, bool _paused)',
      'function pause(string _identifier)',
      'function paused() view returns (bool paused_)',
      'function unpause()',
      'function version() view returns (string)',
    ],
  },
  sources: [
    {
      hash: '0x7913a1d7d0c47796c94eb6f8fd87a89ae9f2716eda57c9be4fd2b27c70bed617',
      name: 'Proxy',
      address: CORRECT_SUPERCHAIN_CONFIG_ADDR,
      source: {
        name: 'Proxy',
        isVerified: true,
        abi: [
          'constructor(address _admin)',
          'event AdminChanged(address previousAdmin, address newAdmin)',
          'event Upgraded(address indexed implementation)',
          'function admin() returns (address)',
          'function changeAdmin(address _admin)',
          'function implementation() returns (address)',
          'function upgradeTo(address _implementation)',
          'function upgradeToAndCall(address _implementation, bytes _data) payable returns (bytes)',
        ],
        solidityVersion: 'v0.8.15+commit.e14f2714',
        constructorArguments:
          '0000000000000000000000004d4733708ab68508969ed3eae083ed4c281c406b',
        remappings: [
          '@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/',
          '@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/',
          '@rari-capital/solmate/=lib/solmate/',
          '@cwia/=lib/clones-with-immutable-args/src/',
          'forge-std/=lib/forge-std/src/',
          'ds-test/=lib/forge-std/lib/ds-test/src/',
          'clones-with-immutable-args/=lib/clones-with-immutable-args/src/',
          'openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/',
          'openzeppelin-contracts/=lib/openzeppelin-contracts/',
          'solmate/=lib/solmate/src/',
        ],
        files: {
          'src/universal/Proxy.sol':
            '// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Constants } from "../libraries/Constants.sol";\n\n/// @title Proxy\n/// @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\n///         if the caller is address(0), meaning that the call originated from an off-chain\n///         simulation.\ncontract Proxy {\n    /// @notice An event that is emitted each time the implementation is changed. This event is part\n    ///         of the EIP-1967 specification.\n    /// @param implementation The address of the implementation contract\n    event Upgraded(address indexed implementation);\n\n    /// @notice An event that is emitted each time the owner is upgraded. This event is part of the\n    ///         EIP-1967 specification.\n    /// @param previousAdmin The previous owner of the contract\n    /// @param newAdmin      The new owner of the contract\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /// @notice A modifier that reverts if not called by the owner or by address(0) to allow\n    ///         eth_call to interact with this proxy without needing to use low-level storage\n    ///         inspection. We assume that nobody is able to trigger calls from address(0) during\n    ///         normal EVM execution.\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /// @notice Sets the initial admin during contract deployment. Admin address is stored at the\n    ///         EIP-1967 admin storage slot so that accidental storage collision with the\n    ///         implementation is not possible.\n    /// @param _admin Address of the initial contract admin. Admin as the ability to access the\n    ///               transparent proxy interface.\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /// @notice Set the implementation contract address. The code at the given address will execute\n    ///         when this contract is called.\n    /// @param _implementation Address of the implementation contract.\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /// @notice Set the implementation and call a function in a single transaction. Useful to ensure\n    ///         atomic execution of initialization-based upgrades.\n    /// @param _implementation Address of the implementation contract.\n    /// @param _data           Calldata to delegatecall the new implementation with.\n    function upgradeToAndCall(\n        address _implementation,\n        bytes calldata _data\n    )\n        public\n        payable\n        virtual\n        proxyCallIfNotAdmin\n        returns (bytes memory)\n    {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, "Proxy: delegatecall to new implementation contract failed");\n        return returndata;\n    }\n\n    /// @notice Changes the owner of the proxy contract. Only callable by the owner.\n    /// @param _admin New owner of the proxy contract.\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /// @notice Gets the owner of the proxy contract.\n    /// @return Owner address.\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    //// @notice Queries the implementation address.\n    /// @return Implementation address.\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice Sets the implementation address.\n    /// @param _implementation New implementation address.\n    function _setImplementation(address _implementation) internal {\n        bytes32 proxyImplementation = Constants.PROXY_IMPLEMENTATION_ADDRESS;\n        assembly {\n            sstore(proxyImplementation, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /// @notice Changes the owner of the proxy contract.\n    /// @param _admin New owner of the proxy contract.\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        bytes32 proxyOwner = Constants.PROXY_OWNER_ADDRESS;\n        assembly {\n            sstore(proxyOwner, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /// @notice Performs the proxy call via a delegatecall.\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), "Proxy: implementation not initialized");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn\'t really\n            // matter because we\'ll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We\'ll revert too and pass the data up.\n            if iszero(success) { revert(0x0, returndatasize()) }\n\n            // Otherwise we\'ll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /// @notice Queries the implementation address.\n    /// @return Implementation address.\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        bytes32 proxyImplementation = Constants.PROXY_IMPLEMENTATION_ADDRESS;\n        assembly {\n            impl := sload(proxyImplementation)\n        }\n        return impl;\n    }\n\n    /// @notice Queries the owner of the proxy contract.\n    /// @return Owner address.\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        bytes32 proxyOwner = Constants.PROXY_OWNER_ADDRESS;\n        assembly {\n            owner := sload(proxyOwner)\n        }\n        return owner;\n    }\n}\n',
          'src/libraries/Constants.sol':
            "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\n\n/// @title Constants\n/// @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\n///         the stuff used in multiple contracts. Constants that only apply to a single contract\n///         should be defined in that contract instead.\nlibrary Constants {\n    /// @notice Special address to be used as the tx origin for gas estimation calls in the\n    ///         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\n    ///         the minimum gas limit specified by the user is not actually enough to execute the\n    ///         given message and you're attempting to estimate the actual necessary gas limit. We\n    ///         use address(1) because it's the ecrecover precompile and therefore guaranteed to\n    ///         never have any code on any EVM chain.\n    address internal constant ESTIMATION_ADDRESS = address(1);\n\n    /// @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\n    ///         CrossDomainMessenger contracts before an actual sender is set. This value is\n    ///         non-zero to reduce the gas cost of message passing transactions.\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /// @notice The storage slot that holds the address of a proxy implementation.\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\n    bytes32 internal constant PROXY_IMPLEMENTATION_ADDRESS =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @notice The storage slot that holds the address of the owner.\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)`\n    bytes32 internal constant PROXY_OWNER_ADDRESS = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @notice Returns the default values for the ResourceConfig. These are the recommended values\n    ///         for a production network.\n    function DEFAULT_RESOURCE_CONFIG() internal pure returns (ResourceMetering.ResourceConfig memory) {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n        return config;\n    }\n}\n",
          'src/L1/ResourceMetering.sol':
            '// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol";\nimport { Math } from "@openzeppelin/contracts/utils/math/Math.sol";\nimport { Burn } from "../libraries/Burn.sol";\nimport { Arithmetic } from "../libraries/Arithmetic.sol";\n\n/// @custom:upgradeable\n/// @title ResourceMetering\n/// @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n///         updates automatically based on current demand.\nabstract contract ResourceMetering is Initializable {\n    /// @notice Represents the various parameters that control the way in which resources are\n    ///         metered. Corresponds to the EIP-1559 resource metering system.\n    /// @custom:field prevBaseFee   Base fee from the previous block(s).\n    /// @custom:field prevBoughtGas Amount of gas bought so far in the current block.\n    /// @custom:field prevBlockNum  Last block number that the base fee was updated.\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /// @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\n    ///         market. These values should be set with care as it is possible to set them in\n    ///         a way that breaks the deposit gas market. The target resource limit is defined as\n    ///         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\n    ///         single word. There is additional space for additions in the future.\n    /// @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\n    ///                                            can be purchased per block.\n    /// @custom:field elasticityMultiplier         Determines the target resource limit along with\n    ///                                            the resource limit.\n    /// @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\n    /// @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\n    ///                                            value.\n    /// @custom:field systemTxMaxGas               The amount of gas supplied to the system\n    ///                                            transaction. This should be set to the same\n    ///                                            number that the op-node sets as the gas limit\n    ///                                            for the system transaction.\n    /// @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\n    ///                                            value.\n    struct ResourceConfig {\n        uint32 maxResourceLimit;\n        uint8 elasticityMultiplier;\n        uint8 baseFeeMaxChangeDenominator;\n        uint32 minimumBaseFee;\n        uint32 systemTxMaxGas;\n        uint128 maximumBaseFee;\n    }\n\n    /// @notice EIP-1559 style gas parameters.\n    ResourceParams public params;\n\n    /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n    uint256[48] private __gap;\n\n    /// @notice Meters access to a function based an amount of a requested resource.\n    /// @param _amount Amount of the resource requested.\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Run the metering function.\n        _metered(_amount, initialGas);\n    }\n\n    /// @notice An internal function that holds all of the logic for metering a resource.\n    /// @param _amount     Amount of the resource requested.\n    /// @param _initialGas The amount of gas before any modifier execution.\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n\n        ResourceConfig memory config = _resourceConfig();\n        int256 targetResourceLimit =\n            int256(uint256(config.maxResourceLimit)) / int256(uint256(config.elasticityMultiplier));\n\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta)\n                / (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = Arithmetic.clamp({\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                _min: int256(uint256(config.minimumBaseFee)),\n                _max: int256(uint256(config.maximumBaseFee))\n            });\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = Arithmetic.clamp({\n                    _value: Arithmetic.cdexp({\n                        _coefficient: newBaseFee,\n                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\n                        _exponent: int256(blockDiff - 1)\n                    }),\n                    _min: int256(uint256(config.minimumBaseFee)),\n                    _max: int256(uint256(config.maximumBaseFee))\n                });\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= int256(uint256(config.maxResourceLimit)),\n            "ResourceMetering: cannot buy more gas than available gas limit"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don\'t support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn\'t dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we\'re at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = _initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n\n    /// @notice Virtual function that returns the resource config.\n    ///         Contracts that inherit this contract must implement this function.\n    /// @return ResourceConfig\n    function _resourceConfig() internal virtual returns (ResourceConfig memory);\n\n    /// @notice Sets initial resource parameter values.\n    ///         This function must either be called by the initializer function of an upgradeable\n    ///         child contract.\n    // solhint-disable-next-line func-name-mixedcase\n    function __ResourceMetering_init() internal onlyInitializing {\n        params = ResourceParams({ prevBaseFee: 1 gwei, prevBoughtGas: 0, prevBlockNum: uint64(block.number) });\n    }\n}\n',
          'lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol':
            '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport "../../utils/Address.sol";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\'s common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init("MyToken", "MTK");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init("MyToken");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n',
          'lib/openzeppelin-contracts/contracts/utils/math/Math.sol':
            "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n",
          'src/libraries/Burn.sol':
            '// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @title Burn\n/// @notice Utilities for burning stuff.\nlibrary Burn {\n    /// @notice Burns a given amount of ETH.\n    /// @param _amount Amount of ETH to burn.\n    function eth(uint256 _amount) internal {\n        new Burner{ value: _amount }();\n    }\n\n    /// @notice Burns a given amount of gas.\n    /// @param _amount Amount of gas to burn.\n    function gas(uint256 _amount) internal view {\n        uint256 i = 0;\n        uint256 initialGas = gasleft();\n        while (initialGas - gasleft() < _amount) {\n            ++i;\n        }\n    }\n}\n\n/// @title Burner\n/// @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\n///         the contract from the circulating supply. Self-destructing is the only way to remove ETH\n///         from the circulating supply.\ncontract Burner {\n    constructor() payable {\n        selfdestruct(payable(address(this)));\n    }\n}\n',
          'src/libraries/Arithmetic.sol':
            '// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SignedMath } from "@openzeppelin/contracts/utils/math/SignedMath.sol";\nimport { FixedPointMathLib } from "@rari-capital/solmate/src/utils/FixedPointMathLib.sol";\n\n/// @title Arithmetic\n/// @notice Even more math than before.\nlibrary Arithmetic {\n    /// @notice Clamps a value between a minimum and maximum.\n    /// @param _value The value to clamp.\n    /// @param _min   The minimum value.\n    /// @param _max   The maximum value.\n    /// @return The clamped value.\n    function clamp(int256 _value, int256 _min, int256 _max) internal pure returns (int256) {\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\n    }\n\n    /// @notice (c)oefficient (d)enominator (exp)onentiation function.\n    ///         Returns the result of: c * (1 - 1/d)^exp.\n    /// @param _coefficient Coefficient of the function.\n    /// @param _denominator Fractional denominator.\n    /// @param _exponent    Power function exponent.\n    /// @return Result of c * (1 - 1/d)^exp.\n    function cdexp(int256 _coefficient, int256 _denominator, int256 _exponent) internal pure returns (int256) {\n        return (_coefficient * (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\n    }\n}\n',
          'lib/openzeppelin-contracts/contracts/utils/Address.sol':
            '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n',
          'lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol':
            '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n',
          'lib/solmate/src/utils/FixedPointMathLib.sol':
            '// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert("EXP_OVERFLOW");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x\') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x\' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we\'ll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don\'t need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won\'t have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, "UNDEFINED");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don\'t need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The "correct" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That\'s not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don\'t care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, "UNDEFINED");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n',
        },
      },
    },
    {
      hash: CORRECT_SUPERCHAIN_CONFIG_IMPLEMENATION_HASH.toString(),
      name: 'SuperchainConfig',
      address: EthereumAddress('0x53c165169401764778F780a69701385eb0FF19B7'),
      source: {
        name: 'SuperchainConfig',
        isVerified: true,
        abi: [
          'constructor()',
          'event ConfigUpdate(uint8 indexed updateType, bytes data)',
          'event Initialized(uint8 version)',
          'event Paused(string identifier)',
          'event Unpaused()',
          'function GUARDIAN_SLOT() view returns (bytes32)',
          'function PAUSED_SLOT() view returns (bytes32)',
          'function guardian() view returns (address guardian_)',
          'function initialize(address _guardian, bool _paused)',
          'function pause(string _identifier)',
          'function paused() view returns (bool paused_)',
          'function unpause()',
          'function version() view returns (string)',
        ],
        solidityVersion: 'v0.8.15+commit.e14f2714',
        constructorArguments: '',
        remappings: [
          '@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/',
          '@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/',
          '@rari-capital/solmate/=lib/solmate/',
          '@cwia/=lib/clones-with-immutable-args/src/',
          '@lib-keccak/=lib/lib-keccak/contracts/lib/',
          'forge-std/=lib/forge-std/src/',
          'ds-test/=lib/forge-std/lib/ds-test/src/',
          'safe-contracts/=lib/safe-contracts/contracts/',
          'kontrol-cheatcodes/=lib/kontrol-cheatcodes/src/',
          'solady/=lib/solady/src/',
          'clones-with-immutable-args/=lib/clones-with-immutable-args/src/',
          'lib-keccak/=lib/lib-keccak/contracts/',
          'openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/',
          'openzeppelin-contracts/=lib/openzeppelin-contracts/',
          'solmate/=lib/solmate/src/',
        ],
        files: {
          'src/L1/SuperchainConfig.sol':
            '// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol";\nimport { ISemver } from "src/universal/ISemver.sol";\nimport { Storage } from "src/libraries/Storage.sol";\n\n/// @custom:audit none This contracts is not yet audited.\n/// @title SuperchainConfig\n/// @notice The SuperchainConfig contract is used to manage configuration of global superchain values.\ncontract SuperchainConfig is Initializable, ISemver {\n    /// @notice Enum representing different types of updates.\n    /// @custom:value GUARDIAN            Represents an update to the guardian.\n    enum UpdateType {\n        GUARDIAN\n    }\n\n    /// @notice Whether or not the Superchain is paused.\n    bytes32 public constant PAUSED_SLOT = bytes32(uint256(keccak256("superchainConfig.paused")) - 1);\n\n    /// @notice The address of the guardian, which can pause withdrawals from the System.\n    ///         It can only be modified by an upgrade.\n    bytes32 public constant GUARDIAN_SLOT = bytes32(uint256(keccak256("superchainConfig.guardian")) - 1);\n\n    /// @notice Emitted when the pause is triggered.\n    /// @param identifier A string helping to identify provenance of the pause transaction.\n    event Paused(string identifier);\n\n    /// @notice Emitted when the pause is lifted.\n    event Unpaused();\n\n    /// @notice Emitted when configuration is updated.\n    /// @param updateType Type of update.\n    /// @param data       Encoded update data.\n    event ConfigUpdate(UpdateType indexed updateType, bytes data);\n\n    /// @notice Semantic version.\n    /// @custom:semver 1.1.0\n    string public constant version = "1.1.0";\n\n    /// @notice Constructs the SuperchainConfig contract.\n    constructor() {\n        initialize({ _guardian: address(0), _paused: false });\n    }\n\n    /// @notice Initializer.\n    /// @param _guardian    Address of the guardian, can pause the OptimismPortal.\n    /// @param _paused      Initial paused status.\n    function initialize(address _guardian, bool _paused) public initializer {\n        _setGuardian(_guardian);\n        if (_paused) {\n            _pause("Initializer paused");\n        }\n    }\n\n    /// @notice Getter for the guardian address.\n    function guardian() public view returns (address guardian_) {\n        guardian_ = Storage.getAddress(GUARDIAN_SLOT);\n    }\n\n    /// @notice Getter for the current paused status.\n    function paused() public view returns (bool paused_) {\n        paused_ = Storage.getBool(PAUSED_SLOT);\n    }\n\n    /// @notice Pauses withdrawals.\n    /// @param _identifier (Optional) A string to identify provenance of the pause transaction.\n    function pause(string memory _identifier) external {\n        require(msg.sender == guardian(), "SuperchainConfig: only guardian can pause");\n        _pause(_identifier);\n    }\n\n    /// @notice Pauses withdrawals.\n    /// @param _identifier (Optional) A string to identify provenance of the pause transaction.\n    function _pause(string memory _identifier) internal {\n        Storage.setBool(PAUSED_SLOT, true);\n        emit Paused(_identifier);\n    }\n\n    /// @notice Unpauses withdrawals.\n    function unpause() external {\n        require(msg.sender == guardian(), "SuperchainConfig: only guardian can unpause");\n        Storage.setBool(PAUSED_SLOT, false);\n        emit Unpaused();\n    }\n\n    /// @notice Sets the guardian address. This is only callable during initialization, so an upgrade\n    ///         will be required to change the guardian.\n    /// @param _guardian The new guardian address.\n    function _setGuardian(address _guardian) internal {\n        Storage.setAddress(GUARDIAN_SLOT, _guardian);\n        emit ConfigUpdate(UpdateType.GUARDIAN, abi.encode(_guardian));\n    }\n}\n',
          'lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol':
            '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport "../../utils/Address.sol";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\'s common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init("MyToken", "MTK");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init("MyToken");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n',
          'src/universal/ISemver.sol':
            '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice ISemver is a simple contract for ensuring that contracts are\n///         versioned using semantic versioning.\ninterface ISemver {\n    /// @notice Getter for the semantic version of the contract. This is not\n    ///         meant to be used onchain but instead meant to be used by offchain\n    ///         tooling.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n',
          'src/libraries/Storage.sol':
            "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Storage\n/// @notice Storage handles reading and writing to arbitary storage locations\nlibrary Storage {\n    /// @notice Returns an address stored in an arbitrary storage slot.\n    ///         These storage slots decouple the storage layout from\n    ///         solc's automation.\n    /// @param _slot The storage slot to retrieve the address from.\n    function getAddress(bytes32 _slot) internal view returns (address addr_) {\n        assembly {\n            addr_ := sload(_slot)\n        }\n    }\n\n    /// @notice Stores an address in an arbitrary storage slot, `_slot`.\n    /// @param _slot The storage slot to store the address in.\n    /// @param _address The protocol version to store\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting addresses\n    ///      in arbitrary storage slots.\n    function setAddress(bytes32 _slot, address _address) internal {\n        assembly {\n            sstore(_slot, _address)\n        }\n    }\n\n    /// @notice Returns a uint256 stored in an arbitrary storage slot.\n    ///         These storage slots decouple the storage layout from\n    ///         solc's automation.\n    /// @param _slot The storage slot to retrieve the address from.\n    function getUint(bytes32 _slot) internal view returns (uint256 value_) {\n        assembly {\n            value_ := sload(_slot)\n        }\n    }\n\n    /// @notice Stores a value in an arbitrary storage slot, `_slot`.\n    /// @param _slot The storage slot to store the address in.\n    /// @param _value The protocol version to store\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\n    ///      in arbitrary storage slots.\n    function setUint(bytes32 _slot, uint256 _value) internal {\n        assembly {\n            sstore(_slot, _value)\n        }\n    }\n\n    /// @notice Returns a bytes32 stored in an arbitrary storage slot.\n    ///         These storage slots decouple the storage layout from\n    ///         solc's automation.\n    /// @param _slot The storage slot to retrieve the address from.\n    function getBytes32(bytes32 _slot) internal view returns (bytes32 value_) {\n        assembly {\n            value_ := sload(_slot)\n        }\n    }\n\n    /// @notice Stores a bytes32 value in an arbitrary storage slot, `_slot`.\n    /// @param _slot The storage slot to store the address in.\n    /// @param _value The bytes32 value to store.\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\n    ///      in arbitrary storage slots.\n    function setBytes32(bytes32 _slot, bytes32 _value) internal {\n        assembly {\n            sstore(_slot, _value)\n        }\n    }\n\n    /// @notice Stores a bool value in an arbitrary storage slot, `_slot`.\n    /// @param _slot The storage slot to store the bool in.\n    /// @param _value The bool value to store\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\n    ///      in arbitrary storage slots.\n    function setBool(bytes32 _slot, bool _value) internal {\n        assembly {\n            sstore(_slot, _value)\n        }\n    }\n\n    /// @notice Returns a bool stored in an arbitrary storage slot.\n    /// @param _slot The storage slot to retrieve the bool from.\n    function getBool(bytes32 _slot) internal view returns (bool value_) {\n        assembly {\n            value_ := sload(_slot)\n        }\n    }\n}\n",
          'lib/openzeppelin-contracts/contracts/utils/Address.sol':
            '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n',
        },
      },
    },
  ],
}
