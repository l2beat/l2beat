import { exec } from 'child_process'
import { assert, getEnv } from '@l2beat/backend-tools'
import { RateLimitedProvider } from '@l2beat/discovery'
import { RawDiscoveryConfig } from '@l2beat/discovery/dist/discovery/config/RawDiscoveryConfig'
import { EthereumAddress, notUndefined } from '@l2beat/shared-pure'
import { providers, utils } from 'ethers'
import { readFile, writeFile } from 'fs/promises'
import { setTimeout } from 'timers/promises'

import { tokenList } from '../../src'
import { ProjectDiscovery } from '../../src/discovery/ProjectDiscovery'
import { scrapEtherscanForTvl } from '../utils/scrapEtherscanForTvl'

const plugAbi = ['function hub__() view returns (address)']
const plugInt = new utils.Interface(plugAbi)

const vaultAbi = ['function token__() view returns (address)']
const vaultInt = new utils.Interface(vaultAbi)

// this is not a plug, but appears in the discovery output
const EXCLUDED_PLUGS = [
  '0x7a6Edde81cdD9d75BC10D87C490b132c08bD426D',
  '0x280D208f0eE2f053A0441099bcBFf298bc8b9444', //TODO: check what is this
  '0x37091ade7C4E1A914D3155449e25eE91DA08EbE4', //TODO: check what is this
]

const SOCKET_DISCOVERY_CONFIG_PATH =
  '../backend/discovery/socket/ethereum/config.jsonc'

/**
 * This script finds all vaults that are connected to the socket bridge via plugs.
 * The vaults are used as escrows for the socket bridge.
 * It is separated from discovery as every additional plur requires modifying the
 * discovery config. The output should be studied carefully to make sure that we add
 * all the relevant escrows.
 *
 * Note that this script only works with standard plugs. If a plug is not standard,
 * the script will fail, so a non-standard plug needs to be excluded.
 *
 * The output of this script is saved in src/projects/bridges/socket-vaults.json.
 */
async function main() {
  const env = getEnv()

  const discovery = new ProjectDiscovery('socket')
  const plugs = discovery.getContractValue<string[]>('Socket', 'plugs')
  const plugsFiltered = plugs.filter((x) => !EXCLUDED_PLUGS.includes(x))

  const alchemyProvider = new providers.AlchemyProvider(
    'homestead',
    env.string('ALCHEMY_API_KEY'),
  )
  const provider = new RateLimitedProvider(alchemyProvider, 150)
  const blockNumber = await provider.getBlockNumber()

  console.log('block number: ', blockNumber)
  console.log('getting vaults from plugs list...')
  const vaultsRaw = await Promise.all(
    plugsFiltered.map((plugAddress) =>
      getVaultAddress(plugAddress, provider, blockNumber),
    ),
  )

  const vaults = vaultsRaw
    .filter(notUndefined)
    .filter((x, i, a) => a.indexOf(x) === i)

  console.log(
    'fetching vaults data (this will take around ' +
      (vaults.length * 2).toString() +
      ' seconds)...',
  )
  const vaultsData = []
  for (const vault of vaults) {
    // avoid rate limiting
    await setTimeout(1000)
    const { tvl, ethValue } = await scrapEtherscanForTvl(vault)
    const tokenAddress = await getTokenAddress(vault, provider, blockNumber)
    const token = tokenList.find((t) => t.address?.toString() === tokenAddress)
    vaultsData.push({
      address: vault,
      tvl,
      ethValue,
      token: token?.symbol,
    })
  }

  const significantVaults = vaultsData.filter(
    (v) => v.tvl !== '0' || v.ethValue !== '0.00',
  )

  const comment =
    'This file was autogenerated. Do not modify it by hand, instead use: yarn update-socket'

  await writeFile(
    'src/projects/bridges/socket-vaults.json',
    JSON.stringify(
      { comment, significantVaults, vaults, vaultsData, plugs },
      null,
      2,
    ),
  )

  // THIS PART IS EXPERIMENTAL
  // as it uses flaky dependencies and reading and writing discovery config file by hand
  if (significantVaults.length === 0) {
    console.log('no significant vaults found')
    return
  }
  console.log('reading discovery config...')
  const discoveryConfig = await readSocketDiscoveryConfig()

  if (
    significantVaults.every((v) =>
      discoveryConfig.initialAddresses.find((x) => x.toString() === v.address),
    )
  ) {
    console.log('all significant vaults already discovered')
    return
  }

  for (const vault of significantVaults) {
    const vaultAddress = EthereumAddress(vault.address)
    if (!discoveryConfig.initialAddresses.includes(vaultAddress)) {
      discoveryConfig.initialAddresses.push(vaultAddress)
      assert(
        vault.token,
        'Vault ' + vault.address + ' does not have token associated',
      )
      const vaultName = vault.token + ' Vault'
      const names = discoveryConfig.names
      assert(names)
      names[vaultAddress.toString()] = vaultName

      const overrides = discoveryConfig.overrides
      assert(overrides)
      overrides[vaultName] = {
        ignoreMethods: ['token__'],
      }
    }
  }
  console.log('writing new discovery config...')
  await writeFile(
    SOCKET_DISCOVERY_CONFIG_PATH,
    JSON.stringify(
      {
        $schema:
          'https://raw.githubusercontent.com/l2beat/tools/main/schemas/config.schema.json',
        chain: discoveryConfig.chain,
        name: discoveryConfig.name,
        initialAddresses: discoveryConfig.initialAddresses,
        names: discoveryConfig.names,
        overrides: discoveryConfig.overrides,
      },
      null,
      2,
    ),
  )

  console.log('formatting...')
  exec('cd ../backend && yarn format:fix')

  console.log('running discovery...')
  exec('cd ../backend && yarn discover ethereum socket')
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})

async function readSocketDiscoveryConfig() {
  const file = await readFile(SOCKET_DISCOVERY_CONFIG_PATH, 'utf-8')
  const parsed = (await JSON.parse(file)) as unknown
  const discoveryConfig = RawDiscoveryConfig.parse(parsed)
  return discoveryConfig
}

async function getTokenAddress(
  vaultAddress: string,
  provider: RateLimitedProvider,
  blockNumber: number,
) {
  const tx = {
    to: vaultAddress,
    data: vaultInt.encodeFunctionData('token__', []),
  }
  const tokenAddressBytes = await provider.call(tx, blockNumber)
  return getAddressFromBytes(tokenAddressBytes)
}

async function getVaultAddress(
  plugAddress: string,
  provider: RateLimitedProvider,
  blockNumber: number,
): Promise<string> {
  const tx = {
    to: plugAddress,
    data: plugInt.encodeFunctionData('hub__', []),
  }

  try {
    const addressBytes = await provider.call(tx, blockNumber)
    return getAddressFromBytes(addressBytes)
  } catch (e) {
    if (
      e instanceof Error &&
      e.message.includes('Transaction reverted without a reason string')
    ) {
      console.error(
        `Plug ${plugAddress} is not a standard plug. It probably needs to be excluded and checked manually.`,
      )
      process.exit(1)
    }
    throw e
  }
}

function getAddressFromBytes(bytes: string) {
  return utils.getAddress('0x' + bytes.slice(26))
}
