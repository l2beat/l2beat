import { getEnv } from '@l2beat/backend-tools'
import { notUndefined } from '@l2beat/shared-pure'
import { providers, utils } from 'ethers'
import { writeFile } from 'fs/promises'
import { setTimeout } from 'timers/promises'

import { tokenList } from '../../src'
import { ProjectDiscovery } from '../../src/discovery/ProjectDiscovery'
import { scrapEtherscanForTvl } from '../utils/scrapEtherscanForTvl'

const plugAbi = ['function hub__() view returns (address)']
const plugInt = new utils.Interface(plugAbi)

const vaultAbi = ['function token__() view returns (address)']
const vaultInt = new utils.Interface(vaultAbi)

// this is not a plug, but appears in the discovery output
const EXCLUDED_PLUGS = ['0x7a6Edde81cdD9d75BC10D87C490b132c08bD426D']

/**
 * This script finds all vaults that are connected to the socket bridge via plugs.
 * The vaults are used as escrows for the socket bridge.
 * It is separated from discovery as every additional plur requires modifying the
 * discovery config. The output should be studied carefully to make sure that we add
 * all the relevant escrows.
 *
 * Note that this script only works with standard plugs. If a plug is not standard,
 * the script will fail, so a non-standard plug needs to be excluded.
 *
 * The output of this script is saved in src/bridges/socket-vaults.json.
 */
async function main() {
  const env = getEnv()

  const discovery = new ProjectDiscovery('socket')
  const plugs = discovery.getContractValue<string[]>('Socket', 'plugs')
  const plugsFiltered = plugs.filter((x) => !EXCLUDED_PLUGS.includes(x))

  const provider = new providers.AlchemyProvider(
    'homestead',
    env.string('ALCHEMY_API_KEY'),
  )
  const blockNumber = await provider.getBlockNumber()

  console.log('block number: ', blockNumber)
  console.log('getting vaults from plugs list...')
  const vaultsRaw = await Promise.all(
    plugsFiltered.map((plugAddress) =>
      getVaultAddress(plugAddress, provider, blockNumber),
    ),
  )

  const vaults = vaultsRaw
    .filter(notUndefined)
    .filter((x, i, a) => a.indexOf(x) === i)

  console.log(
    'fetching vaults data (this will take around ' +
      (vaults.length * 2).toString() +
      ' seconds)...',
  )
  const vaultsData = []
  for (const vault of vaults) {
    // avoid rate limiting
    await setTimeout(1000)
    const { tvl, ethValue } = await scrapEtherscanForTvl(vault)
    const tokenAddress = await getTokenAddress(vault, provider, blockNumber)
    const token = tokenList.find((t) => t.address?.toString() === tokenAddress)
    vaultsData.push({ address: vault, tvl, ethValue, token: token?.symbol })
  }

  const comment =
    'This file was autogenerated. Do not modify it by hand, instead use: yarn update-socket'

  await writeFile(
    'src/bridges/socket-vaults.json',
    JSON.stringify({ comment, vaults, vaultsData, plugs }, null, 2),
  )
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})

async function getTokenAddress(
  vault: string,
  provider: providers.AlchemyProvider,
  blockNumber: number,
) {
  const tx = {
    to: vault,
    data: vaultInt.encodeFunctionData('token__', []),
  }
  const tokenAddressBytes = await provider.call(tx, blockNumber)
  const tokenAddress = utils.getAddress('0x' + tokenAddressBytes.slice(26))
  return tokenAddress
}

async function getVaultAddress(
  plugAddress: string,
  provider: providers.AlchemyProvider,
  blockNumber: number,
): Promise<string> {
  const tx = {
    to: plugAddress,
    data: plugInt.encodeFunctionData('hub__', []),
  }

  try {
    const addressBytes = await provider.call(tx, blockNumber)
    return utils.getAddress('0x' + addressBytes.slice(26))
  } catch (e) {
    if (
      e instanceof Error &&
      e.message.includes('Transaction reverted without a reason string')
    ) {
      console.error(
        `Plug ${plugAddress} is not a standard plug. It probably needs to be excluded and checked manually.`,
      )
      process.exit(1)
    }
    throw e
  }
}
