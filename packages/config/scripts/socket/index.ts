import { exec } from 'child_process'
import { assert, getEnv } from '@l2beat/backend-tools'
import { RateLimitedProvider } from '@l2beat/discovery'
import { RawDiscoveryConfig } from '@l2beat/discovery/dist/discovery/config/RawDiscoveryConfig'
import { EthereumAddress, notUndefined } from '@l2beat/shared-pure'
import { providers, utils } from 'ethers'
import { readFile, writeFile } from 'fs/promises'
import { setTimeout } from 'timers/promises'

import { tokenList } from '../../src'
import { ProjectDiscovery } from '../../src/discovery/ProjectDiscovery'
import { scrapEtherscanForTvl } from '../utils/scrapEtherscanForTvl'

const hubAbi = ['function hub__() view returns (address)']
const hubInt = new utils.Interface(hubAbi)

const bridgeAbi = ['function bridge__() view returns (address)']
const bridgeInt = new utils.Interface(bridgeAbi)

const tokenAbi = [
  'function token__() view returns (address)',
  'function token() view returns (address)',
]
const tokenInt = new utils.Interface(tokenAbi)

// this is not a plug, but appears in the discovery output
const EXCLUDED_PLUGS = [
  '0x7a6Edde81cdD9d75BC10D87C490b132c08bD426D', // TODO: check what is this (Counter)
  '0x280D208f0eE2f053A0441099bcBFf298bc8b9444', // TODO: check what is this (Counter)
  '0x37091ade7C4E1A914D3155449e25eE91DA08EbE4', // TODO: check what is this (SocketPlug)
]

const SOCKET_DISCOVERY_CONFIG_PATH =
  '../backend/discovery/socket/ethereum/config.jsonc'

/**
 * This script finds all vaults that are connected to the socket bridge via plugs.
 * The vaults are used as escrows for the socket bridge.
 * It is separated from discovery as every additional plur requires modifying the
 * discovery config. The output should be studied carefully to make sure that we add
 * all the relevant escrows.
 *
 * Note that this script only works with standard plugs. If a plug is not standard,
 * the script will fail, so a non-standard plug needs to be excluded.
 *
 * The output of this script is saved in src/projects/bridges/socket-vaults.json.
 */
async function main() {
  const env = getEnv()

  const discovery = new ProjectDiscovery('socket')
  const plugs = discovery.getContractValue<string[]>('Socket', 'plugs')
  const plugsFiltered = plugs.filter((x) => !EXCLUDED_PLUGS.includes(x))

  const alchemyProvider = new providers.AlchemyProvider(
    'homestead',
    env.string('ALCHEMY_API_KEY'),
  )
  const provider = new RateLimitedProvider(alchemyProvider, 150)
  const blockNumber = await provider.getBlockNumber()

  console.log('block number: ', blockNumber)
  console.log('getting vaults from plugs list...')
  const vaultsRaw = await Promise.all(
    plugsFiltered.map((plugAddress) =>
      getVaultAddress(plugAddress, provider, blockNumber),
    ),
  )

  const vaults = vaultsRaw
    .filter(notUndefined)
    .filter((x, i, a) => a.indexOf(x) === i)

  console.log(
    'fetching vaults data (this will take around ' +
      (vaults.length * 2).toString() +
      ' seconds)...',
  )
  const vaultsData = []
  for (const vault of vaults) {
    // avoid rate limiting
    await setTimeout(1000)
    const { tvl, ethValue } = await scrapEtherscanForTvl(vault)
    const tokenAddress = await getTokenAddress(vault, provider, blockNumber)
    const token = tokenList.find((t) => t.address?.toString() === tokenAddress)
    vaultsData.push({
      address: vault,
      tvl,
      ethValue,
      token: token?.symbol,
    })
  }

  const significantVaults = vaultsData.filter(
    (v) => v.tvl !== '0' || v.ethValue !== '0.00',
  )

  const comment =
    'This file was autogenerated. Do not modify it by hand, instead use: yarn update-socket'

  await writeFile(
    'src/projects/bridges/socket-vaults.json',
    JSON.stringify(
      { comment, significantVaults, vaults, vaultsData, plugs },
      null,
      2,
    ),
  )

  // THIS PART IS EXPERIMENTAL
  // as it uses flaky dependencies and reading and writing discovery config file by hand
  if (significantVaults.length === 0) {
    console.log('no significant vaults found')
    return
  }
  console.log('reading discovery config...')
  const discoveryConfig = await readSocketDiscoveryConfig()

  if (
    significantVaults.every((v) =>
      discoveryConfig.initialAddresses.find((x) => x.toString() === v.address),
    )
  ) {
    console.log('all significant vaults already discovered')
    return
  }

  for (const vault of significantVaults) {
    const vaultAddress = EthereumAddress(vault.address)
    if (!discoveryConfig.initialAddresses.includes(vaultAddress)) {
      discoveryConfig.initialAddresses.push(vaultAddress)
      assert(
        vault.token,
        'Vault ' + vault.address + ' does not have token associated',
      )
      const vaultName = vault.token + ' Vault'
      const names = discoveryConfig.names
      assert(names)
      names[vaultAddress.toString()] = vaultName

      const overrides = discoveryConfig.overrides
      assert(overrides)
      overrides[vaultName] = {
        ignoreMethods: ['token__'],
      }
    }
  }
  console.log('writing new discovery config...')
  await writeFile(
    SOCKET_DISCOVERY_CONFIG_PATH,
    JSON.stringify(
      {
        $schema:
          'https://raw.githubusercontent.com/l2beat/tools/main/schemas/config.schema.json',
        chain: discoveryConfig.chain,
        name: discoveryConfig.name,
        initialAddresses: discoveryConfig.initialAddresses,
        names: discoveryConfig.names,
        overrides: discoveryConfig.overrides,
      },
      null,
      2,
    ),
  )

  console.log('formatting...')
  exec('cd ../backend && yarn format:fix')

  console.log('running discovery...')
  exec('cd ../backend && yarn discover ethereum socket')
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})

async function readSocketDiscoveryConfig() {
  const file = await readFile(SOCKET_DISCOVERY_CONFIG_PATH, 'utf-8')
  const parsed = (await JSON.parse(file)) as unknown
  const discoveryConfig = RawDiscoveryConfig.parse(parsed)
  return discoveryConfig
}

// sekuba and chatgpt take full responsibility for this. Some newer plugs do not have 'hub__' but 'bridge__' and their vaults do not have 'token__' but 'token'.
async function getTokenAddress(
  vaultAddress: string,
  provider: RateLimitedProvider,
  blockNumber: number,
) {
  let tokenAddressBytes: string

  try {
    const tx = {
      to: vaultAddress,
      data: tokenInt.encodeFunctionData('token__', []),
    }
    tokenAddressBytes = await provider.call(tx, blockNumber)
  } catch (e) {
    if (
      e instanceof Error &&
      e.message.includes('Transaction reverted without a reason string')
    ) {
      console.error(
        `Vault ${vaultAddress} does not have token__(). Trying token()...`,
      )
      const tx = {
        to: vaultAddress,
        data: tokenInt.encodeFunctionData('token', []),
      }
      try {
        tokenAddressBytes = await provider.call(tx, blockNumber)
      } catch (e) {
        console.error(
          `Vault ${vaultAddress} does not have any token set. It probably needs to be excluded and checked manually. (${e})`,
        )
        process.exit(1)
      }
    } else {
      throw e
    }
  }

  return getAddressFromBytes(tokenAddressBytes)
}

async function getVaultAddress(
  plugAddress: string,
  provider: RateLimitedProvider,
  blockNumber: number,
): Promise<string> {
  let addressBytes: string

  try {
    const tx = {
      to: plugAddress,
      data: hubInt.encodeFunctionData('hub__', []),
    }
    addressBytes = await provider.call(tx, blockNumber)
  } catch (e) {
    if (
      e instanceof Error &&
      e.message.includes('Transaction reverted without a reason string')
    ) {
      console.error(
        `Plug ${plugAddress} does not have hub__(). Trying bridge__()...`,
      )
      const tx = {
        to: plugAddress,
        data: bridgeInt.encodeFunctionData('bridge__', []),
      }
      try {
        addressBytes = await provider.call(tx, blockNumber)
      } catch (e) {
        console.error(
          `Plug ${plugAddress} does not have hub__() nor bridge__() functions. It probably needs to be excluded and checked manually. (${e})`,
        )
        process.exit(1)
      }
    } else {
      throw e
    }
  }

  return getAddressFromBytes(addressBytes)
}

function getAddressFromBytes(bytes: string) {
  return utils.getAddress('0x' + bytes.slice(26))
}
