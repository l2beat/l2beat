import { exec } from 'child_process'
import { assert, getEnv } from '@l2beat/backend-tools'
import { RateLimitedProvider } from '@l2beat/discovery'
import { RawDiscoveryConfig } from '@l2beat/discovery/dist/discovery/config/RawDiscoveryConfig'
import { EthereumAddress, notUndefined } from '@l2beat/shared-pure'
import { providers, utils } from 'ethers'
import { readFile, writeFile } from 'fs/promises'
import { parse as parseJSONC } from 'jsonc-parser'
import { setTimeout } from 'timers/promises'

import { tokenList } from '../../src'
import { ProjectDiscovery } from '../../src/discovery/ProjectDiscovery'
import { scrapEtherscanForTvl } from '../utils/scrapEtherscanForTvl'

const hubAbi = ['function hub__() view returns (address)']
const hubInt = new utils.Interface(hubAbi)

const bridgeAbi = ['function bridge__() view returns (address)']
const bridgeInt = new utils.Interface(bridgeAbi)

const tokenAbi = [
  'function token__() view returns (address)',
  'function token() view returns (address)',
]
const tokenInt = new utils.Interface(tokenAbi)

const EXCLUDED_PLUGS = [
  '0x7a6Edde81cdD9d75BC10D87C490b132c08bD426D', // TODO: check what is this (Counter)
  '0x280D208f0eE2f053A0441099bcBFf298bc8b9444', // TODO: check what is this (Counter)
  '0x37091ade7C4E1A914D3155449e25eE91DA08EbE4', // TODO: check what is this (SocketPlug)
]

const SOCKET_DISCOVERY_CONFIG_PATH =
  '../backend/discovery/socket/ethereum/config.jsonc'

/**
 * This script finds all vaults that are connected to the socket bridge via plugs.
 * The vaults are used as escrows for the socket bridge.
 * It is separated from discovery as every additional plug requires modifying the
 * discovery config. The output should be studied carefully to make sure that we add
 * all the relevant escrows.
 *
 * Note that this script only works with standard plugs. If a plug is not standard,
 * the script will fail, so a non-standard plug needs to be excluded.
 *
 * The output of this script is saved in src/projects/bridges/socket-vaults.json.
 */
async function main() {
  try {
    const env = getEnv()

    const discovery = new ProjectDiscovery('socket')
    const plugs = discovery.getContractValue<string[]>('Socket', 'plugs')
    const plugsFiltered = plugs.filter((x) => !EXCLUDED_PLUGS.includes(x))

    const alchemyProvider = new providers.AlchemyProvider(
      'homestead',
      env.string('ALCHEMY_API_KEY'),
    )
    const provider = new RateLimitedProvider(alchemyProvider, 150)
    const blockNumber = await provider.getBlockNumber()

    console.log('block number: ', blockNumber)
    console.log('getting vaults from plugs list...')
    const vaultsRaw = await Promise.all(
      plugsFiltered.map((plugAddress) =>
        getVaultAddress(plugAddress, provider, blockNumber),
      ),
    )

    const vaults = vaultsRaw
      .filter(notUndefined)
      .filter((x, i, a) => a.indexOf(x) === i)

    console.log(
      `fetching vaults data (this will take around ${
        vaults.length * 2
      } seconds)...`,
    )
    const vaultsData = []
    for (const vault of vaults) {
      // avoid rate limiting
      await setTimeout(1000)
      const { tvl, ethValue } = await scrapEtherscanForTvl(vault)
      const tokenAddress = await getTokenAddress(vault, provider, blockNumber)
      const token = tokenList.find(
        (t) => t.address?.toString() === tokenAddress,
      )
      vaultsData.push({
        address: vault,
        tvl,
        ethValue,
        token: token?.symbol || tokenAddress, // Use token address if token is not found
      })
    }

    const significantVaults = vaultsData.filter(
      (v) => v.tvl !== '0' || v.ethValue !== '0.00',
    )

    const comment =
      'This file was autogenerated. Do not modify it by hand, instead use: yarn update-socket'

    await writeFile(
      'src/projects/bridges/socket-vaults.json',
      JSON.stringify(
        { comment, significantVaults, vaults, vaultsData, plugs },
        null,
        2,
      ),
    )

    if (significantVaults.length === 0) {
      console.log('no significant vaults found')
      return
    }
    console.log('reading discovery config...')
    const discoveryConfig = await readSocketDiscoveryConfig()

    if (
      significantVaults.every((v) =>
        discoveryConfig.initialAddresses.find(
          (x) => x.toString() === v.address,
        ),
      )
    ) {
      console.log('all significant vaults already discovered')
      return
    }

    discoveryConfig.names = discoveryConfig.names || {}
    discoveryConfig.overrides = discoveryConfig.overrides || {}

    for (const vault of significantVaults) {
      const vaultAddress = EthereumAddress(vault.address)
      if (!discoveryConfig.initialAddresses.includes(vaultAddress)) {
        discoveryConfig.initialAddresses.push(vaultAddress)
        assert(
          vault.token,
          `Vault ${vault.address} does not have a token associated`,
        )
        const vaultName = `${vault.token} Vault`
        discoveryConfig.names[vaultAddress.toString()] = vaultName
        discoveryConfig.overrides[vaultName] = { ignoreMethods: ['token__'] }
      }
    }
    console.log('writing new discovery config...')
    await writeFile(
      SOCKET_DISCOVERY_CONFIG_PATH,
      JSON.stringify(discoveryConfig, null, 2),
    )

    console.log('formatting...')
    exec('cd ../backend && yarn format:fix')

    console.log('running discovery...')
    exec('cd ../backend && yarn discover ethereum socket')
  } catch (e) {
    console.error(e)
    process.exit(1)
  }
}

main()

async function readSocketDiscoveryConfig() {
  const file = await readFile(SOCKET_DISCOVERY_CONFIG_PATH, 'utf-8')
  const parsed = parseJSONC(file) as unknown
  return RawDiscoveryConfig.parse(parsed)
}

// Some newer plugs do not have 'hub__' but 'bridge__' and their vaults do not have 'token__' but 'token'.
async function getTokenAddress(
  vaultAddress: string,
  provider: RateLimitedProvider,
  blockNumber: number,
) {
  let tokenAddressBytes: string
  try {
    const tx = {
      to: vaultAddress,
      data: tokenInt.encodeFunctionData('token__', []),
    }
    tokenAddressBytes = await provider.call(tx, blockNumber)
  } catch (e) {
    if (
      e instanceof Error &&
      e.message.includes('Transaction reverted without a reason string')
    ) {
      console.error(
        `Vault ${vaultAddress} does not have token__(). Trying token()...`,
      )
      const tx = {
        to: vaultAddress,
        data: tokenInt.encodeFunctionData('token', []),
      }
      try {
        tokenAddressBytes = await provider.call(tx, blockNumber)
      } catch (e) {
        console.error(
          `Vault ${vaultAddress} does not have any token set. It probably needs to be excluded and checked manually. (${e})`,
        )
        process.exit(1)
      }
    } else {
      throw e
    }
  }
  return getAddressFromBytes(tokenAddressBytes)
}

async function getVaultAddress(
  plugAddress: string,
  provider: RateLimitedProvider,
  blockNumber: number,
): Promise<string> {
  let addressBytes: string
  try {
    const tx = { to: plugAddress, data: hubInt.encodeFunctionData('hub__', []) }
    addressBytes = await provider.call(tx, blockNumber)
  } catch (e) {
    if (
      e instanceof Error &&
      e.message.includes('Transaction reverted without a reason string')
    ) {
      console.error(
        `Plug ${plugAddress} does not have hub__(). Trying bridge__()...`,
      )
      const tx = {
        to: plugAddress,
        data: bridgeInt.encodeFunctionData('bridge__', []),
      }
      try {
        addressBytes = await provider.call(tx, blockNumber)
      } catch (e) {
        console.error(
          `Plug ${plugAddress} does not have hub__() nor bridge__() functions. It probably needs to be excluded and checked manually. (${e})`,
        )
        process.exit(1)
      }
    } else {
      throw e
    }
  }
  return getAddressFromBytes(addressBytes)
}

function getAddressFromBytes(bytes: string) {
  return utils.getAddress('0x' + bytes.slice(26))
}
