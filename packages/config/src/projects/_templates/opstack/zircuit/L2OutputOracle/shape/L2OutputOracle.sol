// SPDX-License-Identifier: Unknown
pragma solidity 0.8.20;

library Types {
    /// @notice Extension for v2 L2OutputOracle proposals that will be stored alongside
    ///         a regular OutputProposal
    /// @custom:field batchIndex        index of the batch that was used to prove the transition
    /// @custom:field batchHash         hash of the batch that was used to prove the transition
    /// @custom:field poseidonStateRoot poseidon (zktrie) output root after the transition
    struct OutputProposalEx {
        uint256 batchIndex;
        bytes32 batchHash;
        bytes32 poseidonStateRoot;
    }

    /// @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1
    ///         timestamp that the output root is posted. This timestamp is used to verify that the
    ///         finalization period has passed since the output root was submitted.
    /// @custom:field outputRoot    Hash of the L2 output.
    /// @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.
    /// @custom:field l2BlockNumber L2 block number that the output corresponds to.
    struct OutputProposal {
        bytes32 outputRoot;
        uint128 timestamp;
        uint128 l2BlockNumber;
    }

    /// @notice Struct representing the elements that are hashed together to generate an output root
    ///         which itself represents a snapshot of the L2 state.
    /// @custom:field version                  Version of the output root.
    /// @custom:field stateRoot                Root of the state trie at the block of this output.
    /// @custom:field messagePasserStorageRoot Root of the message passer storage trie.
    /// @custom:field latestBlockhash          Hash of the block this output was generated from.
    struct OutputRootProof {
        bytes32 version;
        bytes32 stateRoot;
        bytes32 messagePasserStorageRoot;
        bytes32 latestBlockhash;
    }

    /// @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end
    ///         user (as opposed to a system deposit transaction generated by the system).
    /// @custom:field from        Address of the sender of the transaction.
    /// @custom:field to          Address of the recipient of the transaction.
    /// @custom:field isCreation  True if the transaction is a contract creation.
    /// @custom:field value       Value to send to the recipient.
    /// @custom:field mint        Amount of ETH to mint.
    /// @custom:field gasLimit    Gas limit of the transaction.
    /// @custom:field data        Data of the transaction.
    /// @custom:field l1BlockHash Hash of the block the transaction was submitted in.
    /// @custom:field logIndex    Index of the log in the block the transaction was submitted in.
    struct UserDepositTransaction {
        address from;
        address to;
        bool isCreation;
        uint256 value;
        uint256 mint;
        uint64 gasLimit;
        bytes data;
        bytes32 l1BlockHash;
        uint256 logIndex;
    }

    /// @notice Struct representing a withdrawal transaction.
    /// @custom:field nonce    Nonce of the withdrawal transaction
    /// @custom:field sender   Address of the sender of the transaction.
    /// @custom:field target   Address of the recipient of the transaction.
    /// @custom:field value    Value to send to the recipient.
    /// @custom:field gasLimit Gas limit of the transaction.
    /// @custom:field data     Data of the transaction.
    struct WithdrawalTransaction {
        uint256 nonce;
        address sender;
        address target;
        uint256 value;
        uint256 gasLimit;
        bytes data;
    }
}

interface ISemver {
    /// @notice Getter for the semantic version of the contract. This is not
    ///         meant to be used onchain but instead meant to be used by offchain
    ///         tooling.
    /// @return Semver contract version as a string.
    function version() external view returns (string memory);
}

abstract contract Initializable {
    /**
     * @dev Storage of the initializable contract.
     *
     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions
     * when using with upgradeable contracts.
     *
     * @custom:storage-location erc7201:openzeppelin.storage.Initializable
     */
    struct InitializableStorage {
        /**
         * @dev Indicates that the contract has been initialized.
         */
        uint64 _initialized;
        /**
         * @dev Indicates that the contract is in the process of being initialized.
         */
        bool _initializing;
    }

    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;

    /**
     * @dev The contract is already initialized.
     */
    error InvalidInitialization();

    /**
     * @dev The contract is not initializing.
     */
    error NotInitializing();

    /**
     * @dev Triggered when the contract has been initialized or reinitialized.
     */
    event Initialized(uint64 version);

    /**
     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
     * `onlyInitializing` functions can be used to initialize parent contracts.
     *
     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any
     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in
     * production.
     *
     * Emits an {Initialized} event.
     */
    modifier initializer() {
        // solhint-disable-next-line var-name-mixedcase
        InitializableStorage storage $ = _getInitializableStorage();

        // Cache values to avoid duplicated sloads
        bool isTopLevelCall = !$._initializing;
        uint64 initialized = $._initialized;

        // Allowed calls:
        // - initialSetup: the contract is not in the initializing state and no previous version was
        //                 initialized
        // - construction: the contract is initialized at version 1 (no reininitialization) and the
        //                 current contract is just being deployed
        bool initialSetup = initialized == 0 && isTopLevelCall;
        bool construction = initialized == 1 && address(this).code.length == 0;

        if (!initialSetup && !construction) {
            revert InvalidInitialization();
        }
        $._initialized = 1;
        if (isTopLevelCall) {
            $._initializing = true;
        }
        _;
        if (isTopLevelCall) {
            $._initializing = false;
            emit Initialized(1);
        }
    }

    /**
     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
     * used to initialize parent contracts.
     *
     * A reinitializer may be used after the original initialization step. This is essential to configure modules that
     * are added through upgrades and that require initialization.
     *
     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
     * cannot be nested. If one is invoked in the context of another, execution will revert.
     *
     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
     * a contract, executing them in the right order is up to the developer or operator.
     *
     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.
     *
     * Emits an {Initialized} event.
     */
    modifier reinitializer(uint64 version) {
        // solhint-disable-next-line var-name-mixedcase
        InitializableStorage storage $ = _getInitializableStorage();

        if ($._initializing || $._initialized >= version) {
            revert InvalidInitialization();
        }
        $._initialized = version;
        $._initializing = true;
        _;
        $._initializing = false;
        emit Initialized(version);
    }

    /**
     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
     * {initializer} and {reinitializer} modifiers, directly or indirectly.
     */
    modifier onlyInitializing() {
        _checkInitializing();
        _;
    }

    /**
     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.
     */
    function _checkInitializing() internal view virtual {
        if (!_isInitializing()) {
            revert NotInitializing();
        }
    }

    /**
     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
     * through proxies.
     *
     * Emits an {Initialized} event the first time it is successfully executed.
     */
    function _disableInitializers() internal virtual {
        // solhint-disable-next-line var-name-mixedcase
        InitializableStorage storage $ = _getInitializableStorage();

        if ($._initializing) {
            revert InvalidInitialization();
        }
        if ($._initialized != type(uint64).max) {
            $._initialized = type(uint64).max;
            emit Initialized(type(uint64).max);
        }
    }

    /**
     * @dev Returns the highest version that has been initialized. See {reinitializer}.
     */
    function _getInitializedVersion() internal view returns (uint64) {
        return _getInitializableStorage()._initialized;
    }

    /**
     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
     */
    function _isInitializing() internal view returns (bool) {
        return _getInitializableStorage()._initializing;
    }

    /**
     * @dev Returns a pointer to the storage namespace.
     */
    // solhint-disable-next-line var-name-mixedcase
    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
        assembly {
            $.slot := INITIALIZABLE_STORAGE
        }
    }
}

contract L2OutputOracle is Initializable, ISemver {
    modifier onlySystemOwner() {
        require(msg.sender == systemOwner, "L2OutputOracle: Caller is not the system owner");
        _;
    }

    modifier v1Only() {
        require(l2OutputsEx.length == 0, "L2OutputOracle: v2 is already active, cannot use v1");
        _;
    }

    modifier v2Only() {
        require(l2OutputsEx.length != 0, "L2OutputOracle: v2 is not active yet, use v1");
        _;
    }

    /// @notice The number of the first L2 block recorded in this contract.
    uint256 public startingBlockNumber;

    /// @notice The timestamp of the first L2 block recorded in this contract.
    uint256 public startingTimestamp;

    /// @notice Array of L2 output proposals.
    Types.OutputProposal[] internal l2Outputs;

    /// @notice The minimum time (in seconds) that must elapse before a withdrawal can be finalized.
    /// @custom:network-specific
    uint256 public finalizationPeriodSeconds;

    /// @notice Legacy, used to be the submission interval.
    /// @custom:network-specific
    uint256 spacer_4_0_32;

    /// @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.
    /// @custom:network-specific
    uint256 public l2BlockTime;

    /// @notice The address of the challenger
    /// @custom:network-specific
    address public challenger;

    /// @notice The address of the System Owner. Can change the finalization period time
    address public systemOwner;

    /// @notice The address of the proposer
    /// @custom:network-specific
    address public proposer;

    /// @notice The address of the verifier
    Verifier public verifier;

    /// @notice The chain ID of the L2
    uint256 public l2ChainId;

    /// @notice The address of the V2 verifier
    address public verifierV2;

    /// @notice Array of L2 output proposals.
    ///         This will follow the same indices as `l2Outputs` after transitioning to v2 by left-padding
    ///         it with empty elements.
    Types.OutputProposalEx[] internal l2OutputsEx;

    /// @notice Time that needs to pass after the last output's l2 timestamp before the proposer can bypass the
    ///         verifier to keep withdrawals live.
    uint256 public withdrawalKeepalivePeriodSeconds;

    /// @notice Emitted when an output is proposed.
    /// @param outputRoot    The output root.
    /// @param l2OutputIndex The index of the output in the l2Outputs array.
    /// @param l2BlockNumber The L2 block number of the output root.
    /// @param l1Timestamp   The L1 timestamp when proposed.
    event OutputProposed(
        bytes32 indexed outputRoot, uint256 indexed l2OutputIndex, uint256 indexed l2BlockNumber, uint256 l1Timestamp
    );

    /// @notice Emitted when a v2 output is proposed.
    /// @param poseidonStateRoot The output root.
    /// @param l2OutputIndex The index of the output in the l2Outputs/l2OutputsEx array.
    /// @param batchIndex The batch index of the proof.
    /// @param batchHash  The batch hash of the proof.
    event OutputProposedV2(
        bytes32 indexed poseidonStateRoot, uint256 indexed l2OutputIndex, uint256 batchIndex, bytes32 batchHash
    );

    /// @notice Emitted when outputs are deleted.
    /// @param prevNextOutputIndex Next L2 output index before the deletion.
    /// @param newNextOutputIndex  Next L2 output index after the deletion.
    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);

    /// @notice Semantic version.
    /// @custom:semver 2.0.0
    string public constant version = "2.0.0";

    /// @notice Constructs the L2OutputOracle contract. Initializes variables to the same values as
    ///         in the getting-started config.
    constructor() {
        initialize({
            _l2BlockTime: 1,
            _startingBlockNumber: 0,
            _startingTimestamp: 0,
            _proposer: address(0),
            _challenger: address(0),
            _verifier: address(0),
            _finalizationPeriodSeconds: 0,
            _withdrawalKeepalivePeriodSeconds: 0,
            _systemOwner: address(0),
            _l2ChainId: 0,
            _verifierV2: address(0)
        });
    }

    /// @notice Initializer.
    /// @param _l2ChainId           The chain id of the L2.
    /// @param _l2BlockTime         The time per L2 block, in seconds.
    /// @param _startingBlockNumber The number of the first L2 block.
    /// @param _startingTimestamp   The timestamp of the first L2 block.
    /// @param _proposer            The address of the proposer.
    /// @param _challenger          The address of the challenger.
    /// @param _verifier            The address of the verifier contract.
    /// @param _verifierV2          The address of the verifierV2 contract.
    /// @param _finalizationPeriodSeconds The minimum time (in seconds) that must elapse before a withdrawal
    ///                                   can be finalized.
    /// @param _systemOwner         The address of the system owner.
    function initialize(
        uint256 _l2ChainId,
        uint256 _l2BlockTime,
        uint256 _startingBlockNumber,
        uint256 _startingTimestamp,
        address _proposer,
        address _challenger,
        address _verifier,
        address _verifierV2,
        uint256 _finalizationPeriodSeconds,
        uint256 _withdrawalKeepalivePeriodSeconds,
        address _systemOwner
    )
        public
        initializer
    {
        require(_l2BlockTime > 0, "L2OutputOracle: L2 block time must be greater than 0");
        require(
            _startingTimestamp <= block.timestamp,
            "L2OutputOracle: starting L2 timestamp must be less than current time"
        );

        l2BlockTime = _l2BlockTime;
        startingBlockNumber = _startingBlockNumber;
        startingTimestamp = _startingTimestamp;
        proposer = _proposer;
        challenger = _challenger;
        verifier = Verifier(_verifier);
        systemOwner = _systemOwner;
        finalizationPeriodSeconds = _finalizationPeriodSeconds;
        verifierV2 = _verifierV2;
        l2ChainId = _l2ChainId;
        withdrawalKeepalivePeriodSeconds = _withdrawalKeepalivePeriodSeconds;
    }

    /// @notice Getter for the challenger address.
    ///         Public getter is legacy and will be removed in the future. Use `challenger` instead.
    /// @return Address of the challenger.
    /// @custom:legacy
    function CHALLENGER() external view returns (address) {
        return challenger;
    }

    /// @notice Getter for the proposer address.
    ///         Public getter is legacy and will be removed in the future. Use `proposer` instead.
    /// @return Address of the proposer.
    /// @custom:legacy
    function PROPOSER() external view returns (address) {
        return proposer;
    }

    /// @notice Getter for the l2BlockTime.
    ///         Public getter is legacy and will be removed in the future. Use `l2BlockTime` instead.
    /// @return L2 block time.
    /// @custom:legacy
    function L2_BLOCK_TIME() external view returns (uint256) {
        return l2BlockTime;
    }

    /// @notice Setter for the withdrawalKeepalivePeriodSeconds.
    function setWithdrawalKeepalivePeriodSeconds(uint256 _withdrawalKeepalivePeriodSeconds) external onlySystemOwner {
        withdrawalKeepalivePeriodSeconds = _withdrawalKeepalivePeriodSeconds;
    }

    /// @notice Setter for the finalizationPeriodSeconds.
    function setFinalizationPeriodSeconds(uint256 newFinalizationPeriodLength) external onlySystemOwner {
        // We would never want a value that is larger than a week (like for an OR) and want
        // to avoid anyone being able to DoS the bridge therefore we set an upper bound for the period length
        require(newFinalizationPeriodLength <= 7 days, "L2OutputOracle: Finalization period too long");
        finalizationPeriodSeconds = newFinalizationPeriodLength;
    }

    /// @notice Getter for the finalizationPeriodSeconds
    function FINALIZATION_PERIOD_SECONDS() external view returns (uint256) {
        return finalizationPeriodSeconds;
    }

    /// @notice Getter for the verifier address.
    function VERIFIER() external view returns (address) {
        return address(verifier);
    }

    /// @notice Deletes all output proposals after and including the proposal that corresponds to
    ///         the given output index. Only the challenger address can delete outputs.
    /// @param _l2OutputIndex Index of the first L2 output to be deleted.
    ///                       All outputs after this output will also be deleted.
    // solhint-disable-next-line ordering
    function deleteL2Outputs(uint256 _l2OutputIndex) external {
        require(msg.sender == challenger, "L2OutputOracle: only the challenger address can delete outputs");

        // Make sure we're not *increasing* the length of the array.
        require(
            _l2OutputIndex < l2Outputs.length, "L2OutputOracle: cannot delete outputs after the latest output index"
        );

        // Do not allow deleting any outputs that have already been finalized.
        require(
            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < finalizationPeriodSeconds,
            "L2OutputOracle: cannot delete outputs that have already been finalized"
        );

        uint256 prevNextL2OutputIndex = nextOutputIndex();

        // Use assembly to delete the array elements because Solidity doesn't allow it.
        assembly {
            sstore(l2Outputs.slot, _l2OutputIndex)
            // since the l2OutputsEx array is padded with empty elements to match the same length as l2Outputs, we could
            // technically get into a situation where we delete past the first bootstrapped element if deleteL2Outputs is
            // called shortly after bootstrapping. This is not an issue though, since v2 is now considered active and
            // only v2 functions can be called. Since the state transition will fail with empty elements, bootstrapping
            // is required again, which is essentially the same as if we were to set the length to zero in such a case
            // with the benefit that going back to v1 is not allowed after an upgrade.
            sstore(l2OutputsEx.slot, _l2OutputIndex)
        }

        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);
    }

    function bootstrapV2(
        uint256 _batchIndex,
        bytes32 _batchHash,
        bytes32 _poseidonPostStateRoot,
        bytes32 _outputRoot,
        uint256 _l2BlockNumber,
        bytes32 _l1BlockHash,
        uint256 _l1BlockNumber
    )
        external
    {
        require(msg.sender == proposer, "L2OutputOracle: only the proposer address can propose new outputs");

        require(
            _l2BlockNumber >= nextBlockNumber(),
            "L2OutputOracle: block number must be at least the next expected block number"
        );

        require(
            computeL2Timestamp(_l2BlockNumber) < block.timestamp,
            "L2OutputOracle: cannot propose L2 output in the future"
        );

        require(_outputRoot != bytes32(0), "L2OutputOracle: L2 output proposal cannot be the zero hash");

        if (_l1BlockHash != bytes32(0) && (_l1BlockNumber + 255) >= block.number) {
            // This check allows the proposer to propose an output based on a given L1 block,
            // without fear that it will be reorged out, provided that the block is in the most
            // recent 256 blocks.
            //
            // It will also revert if the blockheight provided is more than 256 blocks behind the
            // chain tip (as the hash will return as zero). This does open the door to a griefing
            // attack in which the proposer's submission is censored until the block is no longer
            // retrievable, if the proposer is experiencing this attack it can simply leave out the
            // blockhash value, and delay submission until it is confident that the L1 block is
            // finalized.
            require(
                blockhash(_l1BlockNumber) == _l1BlockHash,
                "L2OutputOracle: block hash does not match the hash at the expected height"
            );
        }

        uint256 l2OutputsExLength = l2OutputsEx.length;
        // we only allow bootstrapping if we are transitioning to V2
        // OR we haven't had a proof in a while to keep withdrawals live
        if (l2OutputsExLength != 0) {
            uint256 previousL2SubmissionTime = computeL2Timestamp(l2Outputs[l2OutputsExLength - 1].l2BlockNumber);
            require(block.timestamp >= previousL2SubmissionTime + withdrawalKeepalivePeriodSeconds,
                    "L2OutputOracle: already bootstrapped, last proof too recent");
        }

        uint256 l2OutputsLength = l2Outputs.length;
        // if we bootstrap for the first time, artificially make the ex array have the same
        // length as the l2 outputs so the outputs and ex data are always on the same index
        if (l2OutputsExLength == 0) {
            assembly {
                sstore(l2OutputsEx.slot, l2OutputsLength)
            }
        }
        emit OutputProposed(_outputRoot, l2OutputsLength, _l2BlockNumber, block.timestamp);
        emit OutputProposedV2(_poseidonPostStateRoot, l2OutputsLength, _batchIndex, _batchHash);

        // insert the new outputs
        l2Outputs.push(
            Types.OutputProposal({
                outputRoot: _outputRoot,
                timestamp: uint128(block.timestamp),
                l2BlockNumber: uint128(_l2BlockNumber)
            })
        );
        l2OutputsEx.push(
            Types.OutputProposalEx({
                batchIndex: _batchIndex,
                batchHash: _batchHash,
                poseidonStateRoot: _poseidonPostStateRoot
            })
        );
    }

    function verifyV2(bytes calldata bundleProof, bytes memory publicInput) public view {
        address _verifier = verifierV2;
        bytes32 _verifierDigest = VerifierV2(verifierV2).digest();
        bool success;

        // 1. the first 12 * 32 (0x180) bytes of `bundleProof` is `accumulator`
        // 2. the rest bytes of `bundleProof` is the actual `bundle_recursion_proof`
        // 3. Inserted between `accumulator` and `bundle_recursion_proof` are
        //    32 * 13 (0x1a0) bytes, such that:
        //    | start         | end           | field                   |
        //    |---------------|---------------|-------------------------|
        //    | 0x00          | 0x180         | bundleProof[0x00:0x180] |
        //    | 0x180         | 0x180 + 0x20  | verifierDigest          |
        //    | 0x180 + 0x20  | 0x180 + 0x40  | prevStateRoot_hi        |
        //    | 0x180 + 0x40  | 0x180 + 0x60  | prevStateRoot_lo        |
        //    | 0x180 + 0x60  | 0x180 + 0x80  | prevBatchHash_hi        |
        //    | 0x180 + 0x80  | 0x180 + 0xa0  | prevBatchHash_lo        |
        //    | 0x180 + 0xa0  | 0x180 + 0xc0  | postStateRoot_hi        |
        //    | 0x180 + 0xc0  | 0x180 + 0xe0  | postStateRoot_lo        |
        //    | 0x180 + 0xe0  | 0x180 + 0x100 | batchHash_hi            |
        //    | 0x180 + 0x100 | 0x180 + 0x120 | batchHash_lo            |
        //    | 0x180 + 0x120 | 0x180 + 0x140 | layer2ChainId           |
        //    | 0x180 + 0x140 | 0x180 + 0x160 | withdrawRoot_hi         |
        //    | 0x180 + 0x160 | 0x180 + 0x180 | withdrawRoot_lo         |
        //    | 0x180 + 0x180 | 0x180 + 0x1a0 | numRound                |
        //    | 0x180 + 0x1a0 | dynamic       | bundleProof[0x180:]     |
        assembly {
            let p := mload(0x40)
            // bytes memory starts with the length
            let publicInputOffset := add(publicInput, 0x20)
            // 1. copy the accumulator's 0x180 bytes
            calldatacopy(p, bundleProof.offset, 0x180)
            // 2. insert the public input's 0x1a0 bytes
            mstore(add(p, 0x180), _verifierDigest) // verifierDigest
            let value := mload(add(publicInputOffset, 0xc))
            mstore(add(p, 0x1a0), shr(128, value)) // prevStateRoot_hi
            mstore(add(p, 0x1c0), and(value, 0xffffffffffffffffffffffffffffffff)) // prevStateRoot_lo
            value := mload(add(publicInputOffset, 0x2c))
            mstore(add(p, 0x1e0), shr(128, value)) // prevBatchHash_hi
            mstore(add(p, 0x200), and(value, 0xffffffffffffffffffffffffffffffff)) // prevBatchHash_lo
            value := mload(add(publicInputOffset, 0x4c))
            mstore(add(p, 0x220), shr(128, value)) // postStateRoot_hi
            mstore(add(p, 0x240), and(value, 0xffffffffffffffffffffffffffffffff)) // postStateRoot_lo
            value := mload(add(publicInputOffset, 0x6c))
            mstore(add(p, 0x260), shr(128, value)) // batchHash_hi
            mstore(add(p, 0x280), and(value, 0xffffffffffffffffffffffffffffffff)) // batchHash_lo
            value := shr(192, mload(publicInputOffset))
            mstore(add(p, 0x2a0), value) // layer2ChainId
            value := mload(add(publicInputOffset, 0x8c))
            mstore(add(p, 0x2c0), shr(128, value)) // withdrawRoot_hi
            mstore(add(p, 0x2e0), and(value, 0xffffffffffffffffffffffffffffffff)) // withdrawRoot_lo
            value := shr(224, mload(add(publicInputOffset, 0x08)))
            mstore(add(p, 0x300), sub(value, 1)) // numRound, which is numBatches - 1
            // 3. copy all remaining bytes from bundleProof
            calldatacopy(add(p, 0x320), add(bundleProof.offset, 0x180), sub(bundleProof.length, 0x180))
            // 4. call plonk verifier
            success := staticcall(gas(), _verifier, p, add(bundleProof.length, 0x1a0), 0x00, 0x00)
        }
        require(success, "L2OutputOracle: Verifier rejected proof");
    }

    function proposeL2OutputV2(
        uint256 _batchIndex,
        bytes32 _batchHash,
        bytes32 _poseidonPostStateRoot,
        bytes32 _outputRoot, // keccak output root, same as _withdrawRoot but should not be provided to public inputs
        uint256 _l2BlockNumber, // might be the same as _batchIndex from the _batchHeader
        bytes32 _l1BlockHash,
        uint256 _l1BlockNumber,
        bytes calldata _aggrProof // accumulator | bundle_proof
    )
        external
        payable
        v2Only
    {
        require(msg.sender == proposer, "L2OutputOracle: only the proposer address can propose new outputs");

        require(
            _l2BlockNumber >= nextBlockNumber(),
            "L2OutputOracle: block number must be at least the next expected block number"
        );

        require(
            computeL2Timestamp(_l2BlockNumber) < block.timestamp,
            "L2OutputOracle: cannot propose L2 output in the future"
        );

        require(_outputRoot != bytes32(0), "L2OutputOracle: L2 output proposal cannot be the zero hash");

        if (_l1BlockHash != bytes32(0) && (_l1BlockNumber + 255) >= block.number) {
            // This check allows the proposer to propose an output based on a given L1 block,
            // without fear that it will be reorged out, provided that the block is in the most
            // recent 256 blocks.
            //
            // It will also revert if the blockheight provided is more than 256 blocks behind the
            // chain tip (as the hash will return as zero). This does open the door to a griefing
            // attack in which the proposer's submission is censored until the block is no longer
            // retrievable, if the proposer is experiencing this attack it can simply leave out the
            // blockhash value, and delay submission until it is confident that the L1 block is
            // finalized.
            require(
                blockhash(_l1BlockNumber) == _l1BlockHash,
                "L2OutputOracle: block hash does not match the hash at the expected height"
            );
        }
        uint256 l2OutputsLength = l2Outputs.length;
        Types.OutputProposalEx memory prevOutput = l2OutputsEx[l2OutputsLength - 1];

        bytes memory _publicInput = abi.encodePacked(
            uint64(l2ChainId),
            uint32(_batchIndex - prevOutput.batchIndex), // numBatches
            prevOutput.poseidonStateRoot,
            prevOutput.batchHash,
            _poseidonPostStateRoot,
            _batchHash,
            bytes32(uint256(0)) // _withdrawRoot, disabled
        );

        // pack the proof and call verify
        verifyV2(_aggrProof, _publicInput);

        emit OutputProposed(_outputRoot, l2OutputsLength, _l2BlockNumber, block.timestamp);
        emit OutputProposedV2(_poseidonPostStateRoot, l2OutputsLength, _batchIndex, _batchHash);

        // push to both output arrays
        l2Outputs.push(
            Types.OutputProposal({
                outputRoot: _outputRoot,
                timestamp: uint128(block.timestamp),
                l2BlockNumber: uint128(_l2BlockNumber)
            })
        );
        l2OutputsEx.push(
            Types.OutputProposalEx({
                batchIndex: _batchIndex,
                batchHash: _batchHash,
                poseidonStateRoot: _poseidonPostStateRoot
            })
        );
    }

    /// @notice Accepts an outputRoot and the timestamp of the corresponding L2 block.
    ///         The timestamp must be equal to the current value returned by `nextTimestamp()` in
    ///         order to be accepted. This function may only be called by the Proposer.
    /// @param _outputRoot    The L2 output of the checkpoint block.
    /// @param _l2BlockNumber The L2 block number that resulted in _outputRoot.
    /// @param _l1BlockHash   A block hash which must be included in the current chain.
    /// @param _l1BlockNumber The block number with the specified block hash.
    function proposeL2Output(
        bytes32 _outputRoot,
        uint256 _l2BlockNumber,
        bytes32 _l1BlockHash,
        uint256 _l1BlockNumber,
        bytes calldata _proof
    )
        external
        payable
        v1Only
    {
        require(msg.sender == proposer, "L2OutputOracle: only the proposer address can propose new outputs");

        require(
            _l2BlockNumber >= nextBlockNumber(),
            "L2OutputOracle: block number must be at least the next expected block number"
        );

        require(
            computeL2Timestamp(_l2BlockNumber) < block.timestamp,
            "L2OutputOracle: cannot propose L2 output in the future"
        );

        require(_outputRoot != bytes32(0), "L2OutputOracle: L2 output proposal cannot be the zero hash");

        if (_l1BlockHash != bytes32(0) && (_l1BlockNumber + 255) >= block.number) {
            // This check allows the proposer to propose an output based on a given L1 block,
            // without fear that it will be reorged out, provided that the block is in the most
            // recent 256 blocks.
            //
            // It will also revert if the blockheight provided is more than 256 blocks behind the
            // chain tip (as the hash will return as zero). This does open the door to a griefing
            // attack in which the proposer's submission is censored until the block is no longer
            // retrievable, if the proposer is experiencing this attack it can simply leave out the
            // blockhash value, and delay submission until it is confident that the L1 block is
            // finalized.
            require(
                blockhash(_l1BlockNumber) == _l1BlockHash,
                "L2OutputOracle: block hash does not match the hash at the expected height"
            );
        }

        (bool success, ) = address(verifier).staticcall(_proof);
        require(success, "L2OutputOracle: Verifier rejected proof");

        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);

        l2Outputs.push(
            Types.OutputProposal({
                outputRoot: _outputRoot,
                timestamp: uint128(block.timestamp),
                l2BlockNumber: uint128(_l2BlockNumber)
            })
        );
    }

    /// @notice Returns just the relevant information for the OptimismPortal for a withdrawal by index.
    ///         This isolates the OptimismPortal implementation from the implementation details of the L2OO.
    /// @param _l2OutputIndex Index of the output information to return.
    /// @return outputRoot The output root.
    /// @return finalizedTimestamp The timestamp when this output can be considered finalized.
    function getL2OutputRootWithFinalization(uint256 _l2OutputIndex) external view returns (bytes32 outputRoot, uint256 finalizedTimestamp) {
        Types.OutputProposal memory proposal = l2Outputs[_l2OutputIndex];
        outputRoot = proposal.outputRoot;
        finalizedTimestamp = proposal.timestamp + finalizationPeriodSeconds;
    }

    /// @notice Returns an output by index. Needed to return a struct instead of a tuple.
    /// @param _l2OutputIndex Index of the output to return.
    /// @return The output at the given index.
    function getL2Output(uint256 _l2OutputIndex) external view returns (Types.OutputProposal memory) {
        return l2Outputs[_l2OutputIndex];
    }

    /// @notice Returns the extended output by index.
    /// @param _l2OutputIndex Index of the output to return.
    /// @return The output at the given index.
    function getL2OutputEx(uint256 _l2OutputIndex) external view returns (Types.OutputProposalEx memory) {
        return l2OutputsEx[_l2OutputIndex];
    }

    /// @notice Returns the index of the L2 output that checkpoints a given L2 block number.
    ///         Uses a binary search to find the first output greater than or equal to the given
    ///         block.
    /// @param _l2BlockNumber L2 block number to find a checkpoint for.
    /// @return Index of the first checkpoint that commits to the given L2 block number.
    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {
        // Make sure an output for this block number has actually been proposed.
        require(
            _l2BlockNumber <= latestBlockNumber(),
            "L2OutputOracle: cannot get output for a block that has not been proposed"
        );

        // Make sure there's at least one output proposed.
        require(l2Outputs.length > 0, "L2OutputOracle: cannot get output as no outputs have been proposed yet");

        // Find the output via binary search, guaranteed to exist.
        uint256 lo = 0;
        uint256 hi = l2Outputs.length;
        while (lo < hi) {
            uint256 mid = (lo + hi) / 2;
            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }

        return lo;
    }

    /// @notice Returns the L2 output proposal that checkpoints a given L2 block number.
    ///         Uses a binary search to find the first output greater than or equal to the given
    ///         block.
    /// @param _l2BlockNumber L2 block number to find a checkpoint for.
    /// @return First checkpoint that commits to the given L2 block number.
    function getL2OutputAfter(uint256 _l2BlockNumber) external view returns (Types.OutputProposal memory) {
        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];
    }

    /// @notice Returns the number of outputs that have been proposed.
    ///         Will revert if no outputs have been proposed yet.
    /// @return The number of outputs that have been proposed.
    function latestOutputIndex() external view returns (uint256) {
        return l2Outputs.length - 1;
    }

    /// @notice Returns the index of the next output to be proposed.
    /// @return The index of the next output to be proposed.
    function nextOutputIndex() public view returns (uint256) {
        return l2Outputs.length;
    }

    /// @notice Returns the block number of the latest submitted L2 output proposal.
    ///         If no proposals been submitted yet then this function will return the starting
    ///         block number.
    /// @return Latest submitted L2 block number.
    function latestBlockNumber() public view returns (uint256) {
        return l2Outputs.length == 0 ? startingBlockNumber : l2Outputs[l2Outputs.length - 1].l2BlockNumber;
    }

    /// @notice Computes the block number of the next L2 block that needs to be checkpointed.
    /// @return Next L2 block number.
    function nextBlockNumber() public view returns (uint256) {
        return latestBlockNumber() + 1;
    }

    /// @notice Returns the L2 timestamp corresponding to a given L2 block number.
    /// @param _l2BlockNumber The L2 block number of the target block.
    /// @return L2 timestamp of the given block.
    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {
        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * l2BlockTime);
    }
}