import { UnixTime } from '@l2beat/shared-pure'
import { DaEconomicSecurityRisk } from '../common/DaEconomicSecurityRisk'
import { DaFraudDetectionRisk } from '../common/DaFraudDetectionRisk'
import { DasErasureCodingProof } from '../common/DasErasureCodingProof'
import { DasErasureCodingScheme } from '../common/DasErasureCodingScheme'
import { NO_BRIDGE } from '../templates/no-bridge-template'
import type { BlockchainDaLayer } from '../types/DaLayer'
import { SP1Blobstream } from './SP1Blobstream'

export const blobstream = [SP1Blobstream]

export const celestia: BlockchainDaLayer = {
  id: 'celestia',
  type: 'DaLayer',
  kind: 'PublicBlockchain',
  systemCategory: 'public',
  display: {
    name: 'Celestia',
    slug: 'celestia',
    description:
      'Celestia is a modular data availability network that allows L2s to post arbitrary data as blobs.',
    links: {
      websites: ['https://celestia.org/'],
      documentation: ['https://docs.celestia.org/'],
      repositories: ['https://github.com/celestiaorg'],
      apps: [],
      explorers: ['https://celenium.io/'],
      socialMedia: [
        'https://x.com/CelestiaOrg',
        'https://discord.com/invite/YsnTPcSfWQ',
        'https://t.me/CelestiaCommunity',
      ],
    },
  },
  technology: {
    description: `
    ## Architecture
    
    ![Celestia architecture](/images/da-layer-technology/celestia/architecture.png#center)

    ## Consensus
    Celestia uses CometBTF, the canonical implementation of Tendermint consensus protocol. The consensus protocol is fork-free by construction under an honest majority of stake assumption.
    Celestia achieves finality at each block, with an average time between blocks of 12 seconds.
    ## Blobs
    In Celestia, blobs are user-submitted data that do not modify the blockchain state.  
    Each blob has two components, one is a binary object of raw data bytes, and the other is the namespace of the specific application for which the blob data is intended for.\n
    
    ![Blobs](/images/da-layer-technology/celestia/blobs.png#center)

    All data posted in a Celestia blob is divided into chunks of fixed size, called shares, and each blob is arranged in a k * k matrix of shares. Currently k = 64, for a total of 4096 shares.\n

    ![Blobs matrix](/images/da-layer-technology/celestia/blobs-matrix.png#center)

    Celestia shares' rows and columns are erasure-coded into a 2k * 2k matrix and committed to in a Namespaced Merkle Trees (NMTs), a version of a standard Merkle tree using a namespaced hash function. 
    In NMTs, every node in the tree includes the range of namespaces of all its child nodes, allowing applications to request and retrieve data for a specific namespace sub-tree while maintaining all functionalities (e.g., inclusion and range proofs) of a standard Merkle tree.\n

    ![Matrix proofs](/images/da-layer-technology/celestia/matrix-proofs.png#center)

    Ultimately, a single data root (availableDataRoot) of the Merkle tree is computed with the row and column roots as leaves. This data root is included in the block header as the root of commitments to erasure-coded data so that individual shares in the matrix can be proven to belong to a single data root.\n

    ![Data root](/images/da-layer-technology/celestia/data-root.png#center)

    ## Data Availability Sampling (DAS)

    To ensure data availability, Celestia light nodes perform sampling on the 2k x 2k data matrix. Each light node randomly selects a set of unique coordinates within the extended matrix and requests the corresponding data shares and Merkle proofs from full nodes.
    Currently, a Celestia light node must perform a minimum of 16 samples before declaring that a block is available.
    This sampling rate ensures that given the minimum number of unavailable shares, a light client will sample at least one unavailable share with a 99% probability.\n
    For more details on DAS probabilistic analysis, see the Fraud and Data Availability Proofs paper.\n
    
    ![DAS](/images/da-layer-technology/celestia/das.png#center)

    ## Erasure Coding Proof
    Light nodes performing data availability sampling must have the guarantee that the sampled data is erasure coded correctly. In Celestia, light nodes can be notified of a maliciously encoded block through Bad Encoding Fraud Proofs (BEFPs). Full nodes receiving invalid erasure-coded data can generate a fraud-proof to be transmitted to all light and full nodes in the DA network. The proof is generated by full nodes reconstructing the original data from the block data, and verifying that the recomputed data root matches the data root of the block header. 
    Upon receiving and verifying the BEFP, all Celestia nodes should halt providing services (e.g., submitTx).

    ## L2s Data Availability
    L2s can post data to Celestia by submitting blobs through a payForBlobs transaction. The transaction can include data as a single blob or multiple blobs, with the total maximum size determined by the maximum block size. The transaction fee is determined by the size of the data and the current gas price. 
    Applications can then retrieve the data by querying the Celestia blockchain for the data root of the blob and the namespace of the application. The data can be reconstructed by querying the Celestia network for the shares of the data matrix and reconstructing the data using the erasure coding scheme.

    `,
    references: [
      {
        text: 'Celestia Specifications',
        href: 'https://celestiaorg.github.io/celestia-app/specs/index.html',
      },
      {
        text: 'Celestia Core - CometBFT',
        href: 'https://github.com/celestiaorg/celestia-core',
      },
      {
        text: 'Celestia Node - Data Retrieval',
        href: 'https://github.com/celestiaorg/celestia-node/blob/9ff58570ef86e505b718abfc755fd18643a2284c/share/eds/retriever.go#L60',
      },
      {
        text: 'Bad Encoding Fraud Proofs',
        href: 'https://github.com/celestiaorg/celestia-node/blob/main/docs/adr/adr-006-fraud-service.md',
      },
      {
        text: 'Fraud and Data Availability Proofs paper',
        href: 'https://arxiv.org/pdf/1809.09044',
      },
    ],
    risks: [
      {
        category: 'Funds can be lost if',
        text: `a dishonest supermajority of Celestia validators finalizes an unavailable block, and there aren't light nodes on the network verifying data availability, or they fail at social signaling unavailable data.`,
      },
      {
        category: 'Funds can be lost if',
        text: 'a dishonest supermajority of Celestia validators finalizes an unavailable block, and the light nodes on the network cannot collectively reconstruct the block.',
      },
    ],
  },
  bridges: [
    NO_BRIDGE({
      createdAt: new UnixTime(1721138888), // 2024-07-16T14:08:08Z
      layer: 'Celestia',
      description: `The risk profile in this page refers to L2s that do not integrate with a data availability bridge.
        Projects not integrating with a functional DA bridge rely only on the data availability attestation of the sequencer.`,
      technology: {
        description: `No DA bridge is selected. Without a DA bridge, Ethereum has no proof of data availability for this project.\n`,
      },
    }),
    ...blobstream,
  ],
  /*
    Node params sources:
    - unbondingPeriod, finality (time_iota_ms): https://celestiaorg.github.io/celestia-app/specs/params.html
    - pruningWindow: https://github.com/celestiaorg/CIPs/blob/main/cips/cip-4.md
    - block time: https://github.com/celestiaorg/celestia-app/blob/main/pkg/appconsts/consensus_consts.go
    - max block size: (DefaultMaxBytes) https://github.com/celestiaorg/celestia-app/blob/main/pkg/appconsts/initial_consts.go
  */
  consensusAlgorithm: {
    name: 'CometBFT',
    description: `CometBFT is the canonical implementation of the Tendermint consensus algorithm.
    CometBFT allows for a state transition machine to be written in any programming language, and it allows for secure replication across many machines.
    The consensus protocol is fork-free by construction under an honest majority of stake assumption.`,
    blockTime: 15, // goal block time, seconds
    consensusFinality: 1, // 1 second for tendermint, time_iota_ms
    unbondingPeriod: UnixTime.DAY * 21, // staking.UnbondingTime
  },
  dataAvailabilitySampling: {
    erasureCodingScheme: DasErasureCodingScheme.TwoDReedSolomon,
    erasureCodingProof: DasErasureCodingProof.FraudProofs,
  },
  pruningWindow: 86400 * 30, // 30 days in seconds
  throughput: {
    size: 2000, // 2 MB
    frequency: 6, // 6 seconds
  },
  risks: {
    economicSecurity: DaEconomicSecurityRisk.OnChainQuantifiable,
    fraudDetection: DaFraudDetectionRisk.DasWithNoBlobsReconstruction(true),
  },
  economicSecurity: {
    type: 'Celestia',
  },
}
