{
  "$schema": "../../../../discovery/schemas/config.v2.schema.json",
  "chain": "ethereum",
  "name": "taiko",
  "initialAddresses": [
    "0xd60247c6848B7Ca29eDdF63AA924E53dB6Ddd8EC",
    "0x06a9Ab27c7e2255df1815E6CC0168d7755Feb19a",
    "0x68d30f47F19c07bCCEf4Ac7FAE2Dc12FCa3e0dC9",
    "0x4cffe56C947E26D07C14020499776DB3e9AE3a23"
  ],
  "names": {
    "0xd60247c6848B7Ca29eDdF63AA924E53dB6Ddd8EC": "TaikoBridge",
    "0x06a9Ab27c7e2255df1815E6CC0168d7755Feb19a": "TaikoL1Contract",
    "0x68d30f47F19c07bCCEf4Ac7FAE2Dc12FCa3e0dC9": "ProverSet",
    "0x4cffe56C947E26D07C14020499776DB3e9AE3a23": "TierProvider",
    "0x579f40D0BE111b823962043702cabe6Aaa290780": "L1RollupAddressManager",
    "0x9CBeE534B5D8a6280e01a14844Ee8aF350399C7F": "TaikoAdmin",
    "0xEf9EaA1dd30a9AA1df01c36411b5F082aA65fBaa": "L1SharedAddressManager"
  },
  "overrides": {
    "TaikoBridge": {
      "ignoreMethods": [
        "getMessageMinGasLimit", // too many values
        "context" // Multicall failed
      ],
      "fields": {
        "proxiableUUID": {
          "handler": {
            "type": "call",
            "method": "function proxiableUUID() view returns (bytes32)",
            "args": [],
            "expectRevert": true
          }
        }
      }
    },
    "L1SharedAddressManager": {
      "ignoreMethods": ["proxiableUUID"]
    },
    "TaikoL1Contract": {
      "description": "This contract provides functionalities for proposing, proving, and verifying blocks.",
      "fields": {
        "proxiableUUID": {
          "handler": {
            "type": "call",
            "method": "function proxiableUUID() view returns (bytes32)",
            "args": [],
            "expectRevert": true
          }
        },
        // Harcoded values for verifier names, is there a better way?
        "verifier_TIER_SGX" :{
          "handler": {
            "type": "call",
            "method": "function resolve(bytes32 _name, bool _allowZeroAddress) view returns (address)",
            "args": ["0x746965725f736778000000000000000000000000000000000000000000000000", "false"]
          }
        },
        "verifier_TIER_GUARDIAN_MINORITY" :{
          "handler": {
            "type": "call",
            "method": "function resolve(bytes32 _name, bool _allowZeroAddress) view returns (address)",
            "args": ["0x746965725f677561726469616e5f6d696e6f7269747900000000000000000000", "false"]
          }
        },
        "verifier_TIER_GUARDIAN" :{
          "handler": {
            "type": "call",
            "method": "function resolve(bytes32 _name, bool _allowZeroAddress) view returns (address)",
            "args": ["0x746965725f677561726469616e00000000000000000000000000000000000000", "false"]
          }
        },
      }
    },
    "L1RollupAddressManager": {
      "fields": {
        "proxiableUUID": {
          "handler": {
            "type": "call",
            "method": "function proxiableUUID() view returns (bytes32)",
            "args": [],
            "expectRevert": true
          }
        }
      }
    },
    "ProverSet": {
      "description": "A contract that holds TKO token and acts as a Taiko prover. This contract will simply relay `proveBlock` calls to TaikoL1 so msg.sender doesn't need to hold any TKO.",
      "fields": {
        "proxiableUUID": {
          "handler": {
            "type": "call",
            "method": "function proxiableUUID() view returns (bytes32)",
            "args": [],
            "expectRevert": true
          }
        }
      }
    },
    "TierProvider": {
      "ignoreMethods": ["getMinTier"], // too many values
      "fields": {
        // active tier args from TierProvider.getTierIds
        "TIER_SGX": {
          "description": "verifierName, validityBond, contestBond, cooldownWindow, provingWindow, maxBlocksToVerifyPerProof",
          "handler": {
            "type": "call",
            "method": "function getTier(uint16 _tierId) pure returns (tuple(bytes32 verifierName, uint96 validityBond, uint96 contestBond, uint24 cooldownWindow, uint16 provingWindow, uint8 maxBlocksToVerifyPerProof))",
            "args": [200]
          }
        },
        "TIER_GUARDIAN_MINORITY": {
          "description": "tuple args: verifierName, validityBond, contestBond, cooldownWindow, provingWindow, maxBlocksToVerifyPerProof",
          "handler": {
            "type": "call",
            "method": "function getTier(uint16 _tierId) pure returns (tuple(bytes32 verifierName, uint96 validityBond, uint96 contestBond, uint24 cooldownWindow, uint16 provingWindow, uint8 maxBlocksToVerifyPerProof))",
            "args": [900]
          }
        },
        "TIER_GUARDIAN": {
          "description": "tuple args: verifierName, validityBond, contestBond, cooldownWindow, provingWindow, maxBlocksToVerifyPerProof",
          "handler": {
            "type": "call",
            "method": "function getTier(uint16 _tierId) pure returns (tuple(bytes32 verifierName, uint96 validityBond, uint96 contestBond, uint24 cooldownWindow, uint16 provingWindow, uint8 maxBlocksToVerifyPerProof))",
            "args": [1000]
          }
        },
        // INACTIVE
        "TIER_OPTIMISTIC": {
          "description": "tuple args: verifierName, validityBond, contestBond, cooldownWindow, provingWindow, maxBlocksToVerifyPerProof",
          "handler": {
            "type": "call",
            "method": "function getTier(uint16 _tierId) pure returns (tuple(bytes32 verifierName, uint96 validityBond, uint96 contestBond, uint24 cooldownWindow, uint16 provingWindow, uint8 maxBlocksToVerifyPerProof))",
            "args": [100]
          }
        },
        "TIER_SGX_ZKVM": {
          "description": "tuple args: verifierName, validityBond, contestBond, cooldownWindow, provingWindow, maxBlocksToVerifyPerProof",
          "handler": {
            "type": "call",
            "method": "function getTier(uint16 _tierId) pure returns (tuple(bytes32 verifierName, uint96 validityBond, uint96 contestBond, uint24 cooldownWindow, uint16 provingWindow, uint8 maxBlocksToVerifyPerProof))",
            "args": [300]
          }
        }
      }
    }
  }
}
